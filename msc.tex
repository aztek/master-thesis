\input{preamble}

\begin{document}
\input{title}
\input{toc}

\likechapter{Аннотация}
В работе рассматриваются способы формализации вычислений с эффектами некоторыми классами алгебраических структур и ряд синтаксических расширений функциональных языков программирования для работы с ними. В качестве теоретической базы для вывода формальных свойств систем эффектов используется теория категорий. В работе показано, как ограничения вычислительного контекста влияют на выразительность синтаксиса. Результатом является разработанное расширение языка Scala, пре\-доставляющее более модульный синтаксис вычислений с эффектами, чем было представлено ранее.

\likechapter{Введение}
Движущей идеей функционального программирования является приближение программирования к математике\cite{Turner2004}. Многие идеи, возникающие в контексте функциональных языков (и часто произрастающие из попыток формализовать различные их аспекты), впоследствии оказываются заимствованы в промышленных языках и занимают место в числе лучших практик.

Так, отказ от использования изменяемого состояния, значительно уп\-рощающий денотационную семантику языка, общепризнанно стал самым действенным способом борьбы со сложностью параллельных приложений.

Исследования в области теории типов привели к появлению языков, позволяющих закодировать множество инвариантов на уровне типов, что позволяет превратить в ошибки времени компиляции многие классы ошибок времени выполнения (вплоть до полного устранения последних в тотальных языках вроде Agda\cite{norell2009dependently}).

Следующим заимствованием может стать отделение побочных эффектов (а в широком смысле, любых вычислительных эффектов) от чистых вычислений. Возникшая изначально в качестве инструмента для поддержки \emph{функциональной чистоты}\cite{Sabry1998} языков, эта идея оказалась полезным принципом при проектирование программ.

Суть разделения сводится к введению специальных типов данных, инкапсулирующих значение в некотором вычислительном контексте. В отличии от чистого значения, эффективное значение допускает конечный набор операций над собой, зависящий от использованной формализации, такой как аппликативный функтор или монада.

Необходимость организовывать работу с эффективными значениями с помощью специальных операторов привела к появлению ряда расширений функциональных языков программирования, упрощающих синтаксис вычислений с эффектами. Все они основаны на введении специальных форм, раскрываемых в вызовы методы некоторого фиксированного интерфейса, задающего эффект.

Данное исследование представляет собой попытку создания модульного расширения функционального языка программирования, приближающего синтаксис вычислений с эффектами к синтаксису чистых вычислений.

\likechapter{Постановка задачи}
Для формализации эффектов в работе используются понятия функтора, аппликативного функтора и монады. Известно, что они образуют иерархию (т.е. каждый аппликативный функтор является и просто функтором, а каждая монада является аппликативным функтором). Эта иерархия затрагивает и выразительную силу вычисления, которое можно описать в виде операций над эффективными значениями. При этом ни в одном языке не реализовано синтаксического расширения, поддерживающего всю иерархию целиком.

Также ни в одном языке не была сделана попытка приблизить синтаксис вычислений с эффектами к синтаксису чистых вычислений. Расширение обычно представляет собой введение специальных синтаксических форм, в общем случае плохо компонуемых друг с другом и с чистыми вычислениями.

Целью исследования является разработка синтаксического расширения функционального языка программирования, устраняющего указанные недостатки. Реализация расширения должна:
\begin{enumerate}
  \item Упрощать описание вычислений с эффектами, формализованными в виде функторов, аппликативных функторов и монад.
  \item Предоставлять синтаксис, максимально приближенный к синтаксису чистых вычислений.
  \item Единообразно поддерживать вычисления со всей иерархией описанных выше структур.
  \item В зависимости от вычислительной силы использованной формализации эффекта предоставлять адекватные синтаксические средства для описания допустимых в ней вычислений.
\end{enumerate}

Для реализации был выбран язык программирования Scala и доступные в нём средства метапрограммирования. 

\chapter{Вычислительные эффекты}
\section{Понятие вычислительного эффекта}
Построение языка программирования связано с описанием способа интерпретации допустимых в нём выражений. Одним из таких способов интерпретации является заданная \emph{денотационная семантика} (известная также как семантика Скотта-Стрейчи\cite{stoy1977denotational}). Её суть заключается в конструировании математических объектов (\emph{денотаций}, \eng{denotation}), соответствующих сущностям языка.  К примеру, в языке программирования с целыми числами, заданных типом \<Integer\>, объекты этого типа соответствуют элементам множества~$\mathbb{Z}$, а выражение вида $2 + 3$ соответствует применению математической операции сложения целых чисел.

Одной из ключевых особенностей \emph{чисто функциональных} языков программирования (таких как Haskell\cite{hudak1992report}) является то, что интерпретация выражений математическими объектами распространяется и на функции. Так, функция с типом \<Integer \to Integer\> является математической функцией над целыми числами.

Легко видеть, какие при такой интерпретации могут возникнуть трудности, к примеру, при попытке описать семантику императивных языков программирования. Вызов функции в общем случае изменяет состояние конечного автомата и притом может вообще не произвести результата. Ясно, что для такой функции тяжело найти аналог в математике\footnote{Тем не менее, это возможно, хотя, учитывая операционную природу императивных вычислений, для их формализации чаще прибегают к \emph{операционной семантике}.}.

Более того, на практике промышленного программирования встречается масса примеров вычислений, не формализуемых в виде обыкновенных функций. Рассмотрим некоторые из них.

\begin{enumerate}
  \item \textbf{Побочные эффекты.} Иными словами, действия, производимые функцией в дополнении к возврату значения. Сюда входит изменение состояния, наблюдаемое взаимодействие с окружающим миром (такое как ввод-вывод, взаимодействие по сети или системные вызовы), обработка исключений и т.п. Функции, производящие побочный эффект не обладают свойством \emph{ссылочной прозрачности}\cite{sondergaard1990referential} (\eng{referential transparency}), а потому трудны для изучения.
  \item \textbf{Незавершающиеся вычисления}, реализующиеся бесконечными циклами либо неограниченной рекурсией.
  \item \textbf{Вычисления с отсутствующим результатом.} Сюда относятся и функции, производящие побочный эффект, и функции, заданные не на всей области определения (т.е. производящие ошибку времени исполнения при попытке вычислить себя на некоторых аргументах), такой как поиск элемента в (возможно пустом) списке.
  \item \textbf{Недетерминированные вычисления.} Функция возвращает не одно значение, а суперпозицию нескольких значений. Композиция недетерминированных функций возвращает результат, составленный из всех комбинаций недетерминированных значений.
  \item \textbf{Продолжения} (\eng{continuations}) являются абстрактным представлением состояния потока исполнения программы и часто используются для кодирования других управляющих структур в языках программирования.
\end{enumerate}

Подобные примеры, требующие особых формализмов при описании семантики вычислений называются \emph{вычислительными эффектами} (\eng{computational effects}). Производящую эффект функцию будем называть \emph{эффективной функцией} (\eng{effectful function}), а возвращаемое ею значение~--- \emph{эффективным значением} (\eng{effectful value}).

\section{Способы формализации}
Вычисления с эффектами исследуются главным образом в статически-типизированных функциональных языках программирования (таких как упомянутый выше Haskell или Scala\cite{Odersky2004}). Важным вопросом является построение формальной модели, на основе которой можно построить семантику вычислений с эффектами. Чаще всего это делается кодированием эффекта в типе функции, либо введением системы эффектов, ортогональной системе типов. В первом случае разделяется тип чистой функции \<\alpha \to \beta\> и тип эффективной функции \<\alpha \to f \beta\>, где \<f\>~--- это, в некотором смысле, контейнер, содержащий чистое значение. Удобно рассматривать \<f\> как алгебраическую структуру\cite{Staton2013} с заданным набором операций.

\subsection{Системы типов и эффектов}
Системы типов и эффектов (\eng{type and effect system}) стали одним из первых подходов к формализации вычислительных эффектов. В нём в язык по отдельности вводится система типов и система эффектов. 

Жувлот и Гиффорд\cite{Jouvelot1991} представили алгоритм \emph{алгебраической реконструкции} (\eng{algebraic reconstruction}) типов и эффектов для полиморфного языка с поддержкой процедур, как объектов первого рода.

Талпин и Жувлот\cite{Talpin1992} разработали \emph{дисциплину типов и эффектов} (\eng{type and effect discipline})~--- формальный фреймворк, позволяющий реконструировать главный тип (\eng{principal type}) и минимальный эффект выражения в неявно типизированном полиморфном функциональном языке программирования с поддержкой императивных языковых конструкций.

Тофте и Талпин\cite{Tofte1994,tofte1997region} разработали \emph{исчисление регионов} (\eng{region calculus}). Предложенный ими подход помещает все доступные во время исполнения значения (включая замыкания) в \emph{регионы}, образующими стек. Специальный анализ выводит места, где регионы могут быть аллоцированы и деаллоцированы. Основное практическое применение этого формализма~--- построение безопасной модели памяти для языков программирования. Так, язык Cyclone\cite{Jim2002} представляет собой клон C с аннотациями эффектов, повышающими надежность при работе с выделением и освобождением памяти.

Бауэр и Претнар построили язык Eff\cite{Bauer2012}, реализующий \emph{обработчики эффектов} (\eng{effect handlers}) для обработки состояния, I/O, недетерминизма, бэктрекинга и др.

Разновидностью легковесной системы эффектов можно назвать \emph{проверяемые исключения} (\eng{checked exceptions}) в Java\cite{gosling2000java} и других языках. Функция аннотируется типами выбрасываемых исключений, а специальная проверка следит за тем, чтобы реализация не выходила за пределы этих аннотаций~--- т.е. что никакое выражение внутри функции не выбрасывает исключение, не аннотированное в её сигнатуре. Этот анализ несколько усложняется наличием отношения подтипизации у классов исключений.

Существуют попытки добавить легковесную систему эффектов в Scala\cite{Rytz2012}, расширив тип функции аннотацией производимой ей эффекта.

\subsection{Функторы, идиомы, монады}
Наиболее популярным подходом к формализации эффектов является использование перечисленных алгебраических структур. Все они будут в деталях разобраны далее. Пока достаточно сказать, что функтор обобщает понятие контекста, к содержимому которого можно применить чистую функцию и получить изменённый контекст. Аппликативный функтор (также называемый \emph{идиома}, \eng{idiom}) расширяет функтор на случай нескольких контекстов одного типа и чистой функции от нескольких аргументов, которую можно поаргументно применить к содержимому контекстов. Монада обобщает аппликативный функтор на случай зависимости значения одного содержимого контекста от другого.

Вадлер и Тиманн\cite{Wadler2003} показали, что монады можно свести к системе эффектов.

\subsection{Обобщения и специализации монад}
Появление монад в Haskell, как средства для описания вычислительных эффектов, катализировало исследования моноидальных алгебраических структур, пригодных для этой же цели. В частности, были представлены следующие обобщения.

\textbf{Стрелка} (\eng{arrow})~--- обобщение монады, предложенное Джоном Хьюзом\cite{Hughes2000}. В частности, стрелки допускают нотацию вычислений, который могут быть частично статическими (независимыми от входа) или принимать несколько входов. Линдли и др. разработали \emph{исчисление стрелок}\cite{Lindley2010}, метаязык для работы со стрелками наподобие метаязыка для работы с монадами. Ими же были рассмотрены взаимосвязи между всеми этими объектами\cite{Lindley2011}. Для Haskell существует расширение, добавляющее стрелочную нотацию в язык\cite{Paterson2001}.

\textbf{Относительная монада} (\eng{relative monad}) определяет, следуя теоретико-категорному определению, моноид в категории функторов между строго различными категориями (в противовес эндофункторам в определении монады). Альтеркирх и др.\cite{Altenkirch2010a,Altenkirch2010} предложили примеры вычислений, не формализуемых с помощью монад, но допустимых в относительных монадах.

Помимо полезных обобщений, есть и полезные специализации, вносящие дополнительные свойства ценой уменьшения выразительной силы.

\textbf{Аддитивная монада} (\eng{additive monad}) получается добавлением к монаде ассоциативной операции и единицы (фактически~--- моноида). В Haskell ей соответствует класс типов \<MonadPlus\>\cite{auclair2008monadplus}. Аддитивная монада формализует наличие или отсутствие результатов вычисления внутри монадического контекста и допускает свёртку на моноиде из эффективных значений. 

\textbf{Свободная монада} (\eng{free monad})~--- минимальная структура, удовлетворяющая всем законам монады. Их особенность в том, что они, в отличии от монад, коммутируют.

\subsection{Дуальные алгебраические структуры}
Монады и функторы могут рассматриваться в дуальных категориях, что порождает, соответственно комонады\cite{Uustalu2008} и кофункторы. В отличии от монад, комонады предоставляют операции для композиции функций со структурированным входом (а не выходом). Применительно к вычислениям с эффектами они интересны с точки зрения исследования зависимости вычислений от среды, в которой они были запущены\cite{Petricek2013}. Комонады используются для описания потоков данных (\eng{dataflow programming})\cite{uustalu2006essence}, синтеза атрибутов в атрибутивных грамматиках\cite{uustalu2007comonadic}, векторных вычислениях и др. Для вычислениях в комонадах в Haskell предложена специальная \<\hskwd{codo}\>-нотация\cite{Orchard2012}.

\subsection{Расширения систем типов}
Некоторые из формализаций эффектов задействуют специальные свойства систем типов языка программирования. Следует выделить следующее.

\textbf{Зависимые типы.} Эдвин Брейди предложил\cite{Brady2013} подход с использованием обработчиков эффектов для зависимо-типизированного языка Idris. Мотивацией для этого подхода является упрощение добавления эффектов к вычислению (в качестве примера показывается наращивание возможностей абстрактный интерпретатора), поскольку подход с использованием монад предполагает написание для этого трансформеров монад.

\textbf{Линейные типы.} Также известные как \emph{уникальные типы}\cite{Barendsen1996}. Уникальные типы позволяют управлять наблюдаемостью побочных эффектов. Например, зная, что на некоторое значение нет посторонних ссылок, можно его изменить, сохранив функциональную чистоту. Используется в языке Clean\cite{Brus1987}.

\section{Синтаксические расширения}
Для каждой пары чистых функций \<\alpha \to \beta\> и \<\beta \to \gamma\> существует композиция типа \<\alpha \to \gamma\>. Эффективные же функции, в общем случае, не композируются~--- нельзя построить \<\alpha \to f \gamma\> из \<\alpha \to f \beta\> и \<\beta \to f \gamma\>.

В зависимости от структуры \<f\>, над эффективным значением допустими некоторые операции, которые можно использовать для построения сложных вычислений. Так, если контейнер \<f \alpha\> поддерживает операцию \<map\> типа \<(\alpha \to \beta) \to f \alpha \to f \beta\>, можно построить композицию чистой функции \<g\> и эффективной функции \<h\> как \<map g (h a)\>.

Необходимость использовать комбинаторы над эффективными значениями приводит к заметному усложнению кода, что даёт мотивацию для создания синтаксических расширений, упрощающих синтаксис вычислений с эффектами. 

Некоторые функциональные языки программирования предоставляют специальный синтаксис, обычно для монад и аппликативных функторов. Так, Haskell вводит синтаксис \emph{выделения монад} (\eng{monad comprehension}), обобщающий \emph{выделение списков} (\eng{list comprehension}) и \<\hskwd{do}\>-нотацию. Её аналог также реализован в Idris\cite{Brady2008}, Scala (известный как \<\hskwd{for}\>-нотация) и OCaml (\<\hskwd{perform}\>-нотация). F$\sharp$ поддерживает \emph{вычислительные выражения}. Синтаксис для аппликативных вычислений, известный как идиоматические скобки, реализован в Idris и Strathclyde Haskell Enhancement. Все они будут подробно рассмотрены далее.

\chapter{Теоретические основания}
В работе рассматривается формализация вычислений с эффектами аппликативными функторами и монадами. В качестве теоретический основы используется аппарат общей алгебры и теории категорий.

\section{Общая алгебра}
Введём несколько понятий из общей алгебры с примерами из различных областей математики и языков программирования. Определения и большая часть примеров взята из \cite{jacobson2012basic}.

\begin{definition}
  \emph{Полугруппой} называется алгебраическая структура $(\mathfrak{S}, \circ)$, состоящая из множества $\mathfrak{S}$ и замкнутой на нём ассоциативной бинарной операцией $\circ$.
\end{definition}

Исходя из определения, свойствами полугруппы являются:
\begin{enumerate}
 \item \emph{Свойство замыкания.} $\forall a, b \in \mathfrak{S}.~ a \circ b \in \mathfrak{S}$
 \item \emph{Свойство ассоциативности.} $\forall a, b, c \in \mathfrak{S}.~ (a \circ b) \circ c = a \circ (b \circ c)$
\end{enumerate}

Множества чисел $\mathbb{N}$, $\mathbb{Z}$, $\mathbb{Q}$, $\mathbb{R}$ и $\mathbb{C}$ образуют полугруппу по сложению и по умножению. Множество матриц $n \times m$ образуют полугруппу по сложению и вычитанию, а множество квадратных неотрицательных матриц $n \times n$~--- по умножению. Множество конечных строк фиксированного алфавита $\Sigma$ образуют полугруппу относительно конкатенации строк (в этом случае его называют \emph{свободной полугруппой} (\eng{free semigroup})).

Можно найти примеры и в языках программирования, как очевидные, вроде чисел, строк и списков, так и более изощрённые, как лог-файлы, допускающие добавление записи в конец. Легко показать, что такая операция ассоциативна и замкнута относительно типа лог-файла.

Ассоциативность связанной с полугруппой операции может быть основой для оптимизации алгоритмов. Легко показать, как свёртка списка из $n$ элементов полугруппы может быть реализована за $O(\log n)$. На этом факте основан, к примеру, алгоритм бинарного возведения в степень.

\begin{definition}
   \emph{Моноидом} называется алгебраическая структура $(\mathfrak{S}, \circ, e)$, такая, что $(\mathfrak{S}, \circ)$ образуют полугруппу, а $e \in \mathfrak{S}$ является нейтральным элементом операции $\circ$.
\end{definition}

Свойствами моноида являются:
\begin{enumerate}
 \item \emph{Свойство замыкания.} $\forall a, b \in \mathfrak{S}.~ a \circ b \in \mathfrak{S}$
 \item \emph{Свойство нейтральности слева.} $\forall a \in \mathfrak{S}.~ a \circ e = a$
 \item \emph{Свойство нейтральности справа.} $\forall a \in \mathfrak{S}.~ e \circ a = a$
 \item \emph{Свойство ассоциативности.} $\forall a, b, c \in \mathfrak{S}.~ (a \circ b) \circ c = a \circ (b \circ c)$
\end{enumerate}

Как следует из определения, моноид является частным случаем полугруппы. Пример полугруппы, не являющейся моноидом~--- $(\mathbb{Z}, \min)$. Очевидно, что $\min$ ассоциативна, при этом на множестве $\mathbb{Z}$ нельзя выбрать наибольший элемент. Тем не менее, большая часть полугрупп может быть расширена до моноида. Так, упомянутые ранее множества чисел $\mathbb{N}$, $\mathbb{Z}$, $\mathbb{Q}$, $\mathbb{R}$ и $\mathbb{C}$ являются моноидами относительно сложения и нуля и умножения и единицы. Наличие единичной матрицы позволяет считать множество квадратных матриц моноидом по умножению, а наличие нулевой матрицы~--- моноидом по сложению. Среди других примеров~--- $(\mathbb{B}, \wedge, 0)$, $(\mathbb{B}, \vee, 1)$, $(\mathbb{Z}, \mathrm{lcm}, 1)$ и $(\mathbb{Z}, \mathrm{gcd}, 0)$.

Стоит отметить, что операция $\circ$ в общем случае не коммутативна. Обладающие этим свойством моноиды называются \emph{коммутативными}. Примером некоммутативного моноида является множество квадратных матриц с операцией умножения.

Многие абстрактные типы данных в языках программирования обладают моноидальной структурой, например списки (пустой список соответствует нейтральному элементу; непустой список при этом образует полугруппу) и деревья. Вычиcления, задействующие свёртку моноидов активно используются в функциональном программировании\cite{piponi2009haskell}. Так, сумму списка можно выразить с помощью свёртки моноида по сложению, а нахождение максимального элемента~--- свёрткой по операции $\max$.

\section{Теория категорий}
Теория категорий традиционно используется для построения рассуждений о семантике языков программирования. Определения и свойства основных понятий взяты из \cite{lane1998categories} и \cite{barr1995category}. Приложения в языках программирования рассматриваются, в частности, в \cite{pierce1991basic} и \cite{mitchell1996foundations}.

\subsection{Категории, объекты и морфизмы}
\begin{definition}
  \emph{Категорией} $\mathcal{C}$ называется алгебраическая конструкция, состоящая из
  \begin{enumerate}
    \item Набора \emph{объектов}, обозначаемого $\mathrm{Ob}(\mathcal{C})$.
    \item Набора \emph{стрелок} (или \emph{морфизмов}), обозначаемого $\mathrm{Hom}(\mathcal{C})$.
    \item Операций, назначающих каждой стрелке $f$ объект $\mathrm{Dom}(f)$, её область определения (\emph{домен}, \eng{domain}) и объект $\mathrm{Cod}(f)f$, её область значений (\emph{кодомен}, \eng{codomain}). Будем записывать $f : A \to B$, чтобы показать, что  $\mathrm{Dom}(f) = A$, а $\mathrm{Cod}(f) = B$. Набор стрелок с доменом $A$ и кодоменом $B$ будем записывать как $\mathcal{C}(A, B)$.
    \item Оператора композиции, назначающего каждой паре стрелок $f$ и $g$ таких, что $\mathrm{Cod}(f) = \mathrm{Dom}(g)$, стрелку \emph{композиции} $g \circ f : \mathrm{Dom}(f) \to \mathrm{Cod}(g)$, удовлетворяющую \emph{ассоциативному закону}: для любых $f : A \to B$, $g : B \to C$ и $h : C \to D$ (где $A$, $B$, $C$ и $D$ не обязаны быть различными), $h \circ (g \circ f) = (h \circ g) \circ f$.
    \item \emph{Тождественной} стрелки $\mathrm{id}_A : A \to A$ для каждого объекта $A$, удовлетворяющей \emph{закону тождества}: для любой $f : A \to B$, $\mathrm{id}_B \circ f = f$ and $f \circ \mathrm{id}_A = f$.
  \end{enumerate}
\end{definition}

Рассмотрим несколько примеров категорий:
\begin{enumerate}
  \item Категория $\mathcal{S}et$, объектами которой являются множества, а морфизмами~--- тотальные функции между множествами. Композицией морфизмов является теоретико-множественная функция композиции, а тождественным морфизмом является тождественная функция.
  \item Любой ориентированный граф задаёт категорию, где объекты~--- это вершины, а стрелки~--- это связанные пути в графе. Композицией морфизмов является соединение вершин графа, а тождественным морфизмом является путь, в котором нет ни одного ребра.
  \item Любое множество с заданным предпорядком образует категорию. Объектами являются элементы множества, стрелками~--- пары элементов, для которых определено отношение предпорядка. Композиция морфизмов задаётся как $(a, b) \circ (b, c) = (a, c)$, а тождественным морфизмом является пара, состоящая из одинаковых объектов.
  \item Категория $\mathcal{M}on$, объектами которой являются моноиды, а морфизмами~--- моноидные гомоморфизмы (т.е. отображения, сохраняющие нейтральный элемент и замкнутые относительно операции). Композицией морфизмов является композиция гомоморфизмов, а тождественным морфизмом является моноидальный эндоморфизм.
\end{enumerate}

Для всех этих примеров можно показать выполнимость ассоциативного закона и закона тождества.

В определении сознательно используется термин \emph{набор} (\eng{collection}), а не \emph{множество}. Категория $\mathcal{C}$, чьи $\mathrm{Ob}(\mathcal{C})$ и $\mathrm{Hom}(\mathcal{C})$ являются множествами называется \emph{малой}. Категория $\mathcal{C}$, чей $\mathcal{C}(A, B)$ для любых $A$ и $B$ является множеством, называется \emph{локально малой}. Так, категория $\mathcal{S}et$ не является малой, но является локально малой.

Убрав из определения малой категории существование тождественного морфизма для каждого объекта, можно получить структуру, известную как \emph{полугруппоид} (\eng{semigroupoid}).

Для описания категорий часто прибегают к \emph{коммутативным диаграммам}, представляющих собой визуальную нотацию для объектов и стрелок. Объекты на диаграмме показаны как вершины ориентированного графа, стрелки~--- как его рёбра. Коммутативность диаграммы означает то, что для любой пары вершин $X$ и $Y$, все пути из $X$ в $Y$ задают одинаковый морфизм. На рисунке \ref{cd:compose} представлена коммутативная диаграмма категории, состоящей из объектов $A$, $B$ и $C$, и морфизмов $f : A \to B$ и $g : B \to C$.

\begin{figure}[h]
    \centering
    \begin{tikzcd}
      A \arrow[loop left]{}{\mathrm{id}_A} \rar{f} \drar[swap]{f~\circ~g} & B \dar{g}\arrow[loop right]{}{\mathrm{id}_B} \\
      & C \arrow[loop below]{}{\mathrm{id}_C}
    \end{tikzcd}
    \caption{Коммутативная диаграмма композиции морфизмов.}
    \label{cd:compose}
\end{figure}

\begin{definition}
  Категория $\mathcal{C}^{\mathrm{op}}$ называется \emph{дуальной} к категории $\mathcal{C}$, если все свойства $\mathcal{C}^{\mathrm{op}}$ соответствуют свойствам $\mathcal{C}$ с точностью до перестановки домена и кодомена и порядка композиции морфизмов. На коммутативной диаграмме $\mathcal{C}^{\mathrm{op}}$ выглядит, как $\mathcal{C}$ с перевёрнутыми стрелками.
\end{definition}

\begin{definition}
  \emph{Начальным объектом} (\eng{initial object}) $I$ категории $\mathcal{C}$ называется объект, такой, что для любого объекта $A$ существует ровно один морфизм из $I$ в $A$.
\end{definition}

\begin{definition}
  \emph{Конечным объектом} (\eng{terminal object}) $T$ категории $\mathcal{C}$ называется объект, такой, что для любого объекта $A$ существует ровно один морфизм из $A$ в $I$.
\end{definition}

Например, в категории $\mathcal{S}et$ единственным начальным объектом является пустое множество, а любое одноэлементное множество является конечным объектом.

Легко показать, что начальные объекты категории $\mathcal{C}$ являются конечными объектами категории $\mathcal{C}^\mathrm{op}$ и наоборот.

\begin{definition}
  Категория $\mathcal{S}$ называется \emph{подкатегорией} $\mathcal{C}$, если
  \begin{enumerate}
    \item Каждый объект $\mathcal{S}$ является объектом $\mathcal{C}$.
    \item Для любой пары $\mathcal{S}$-объектов $A$ и $B$, $\mathcal{S}(A, B)$ является поднабором $\mathcal{C}(A, B)$.
    \item Тождественные морфизмы и морфизмы композиции категорий совпадают.
  \end{enumerate}
\end{definition}

Интуитивно, подкатегория представляет собой категорию с некоторыми удалёнными объектами и морфизмами.

\subsection{Функторы и естественные преобразования}
\begin{definition}
  Пусть $\mathcal{C}$ и $\mathcal{D}$~--- категории. \emph{Функтором} $$\mathbf{F} : \mathcal{C} \to \mathcal{D}$$ называется отображение каждого $\mathcal{C}$-объекта $A$ в $\mathcal{D}$-объект $\mathbf{F}(A)$ и $\mathcal{C}$-мор\-физ\-ма $f : A \to B$ в $\mathcal{D}$-морфизм $\mathbf{F}(f) : \mathbf{F}(A) \to \mathbf{F}(B)$, такое, что для всех $\mathcal{C}$-объектов $A$ и допускающих композицию $\mathcal{C}$-морфизмов $f$ и $g$ выполняется:
  \begin{enumerate}
    \item $\mathbf{F}(\mathrm{id}_A) = \mathrm{id}_{\mathbf{F}(A)}$
    \item $\mathbf{F}(f \circ g) = \mathbf{F}(f) \circ \mathbf{F}(g)$
  \end{enumerate}
\end{definition}

Интуитивно, функтор является \emph{гомоморфизмом} между категориями, т.е. отображением, сохраняющим тождества и композицию. После отображения морфизма $f : A \xrightarrow[\mathcal{C}]{} B$, получаем морфизм\footnote{Подпись под стрелкой указывает, в какой категории объявлен морфизм.} $\mathbf{F}(f) : \mathbf{F}(A) \xrightarrow[\mathbf{F}(\mathcal{C})]{} \mathbf{F}(B)$, а композиция $f \circ g$ переходит в $\mathbf{F}(f \circ g)$, как показано на рисунке \ref{cd:functor}.

\begin{figure}[h]
  \centering
    \begin{tikzcd}
      A \rar{f} \dar{\mathbf{F}} \arrow[bend left]{rr}{f~\circ~g} & B \rar{g} \dar{\mathbf{F}} & C \dar{\mathbf{F}} \\
      \mathbf{F}(A) \rar{\mathbf{F}(f)} \arrow[bend right]{rr}[swap]{\mathbf{F}(f~\circ~g)} & \mathbf{F}(B) \rar{\mathbf{F}(g)} & \mathbf{F}(C)
    \end{tikzcd}
    \caption{Коммутативная диаграмма функтора $\mathbf{F}$.}
    \label{cd:functor}
\end{figure}

Примером функтора является $\mathbf{F} : \mathcal{M}on \to \mathcal{S}et$, отображающий каждый моноид во множество, на котором он задан, а каждый моноидальный гомоморфизм в функцию между множествами, на которых заданы домен и кодомен. Видно, что при таком отображении часть структуры категории теряется. Чтобы отразить это свойство, такой функтор называют \emph{забывающим} (\eng{forgetful}). 

\begin{definition}
  Функтор $\mathbf{F}: \mathcal{C} \to \mathcal{C}$ называется \emph{эндофунктором}.
\end{definition}

\begin{definition}
  Функтор $\mathbf{F}: \mathcal{C} \times \mathcal{D}$ от двух аргументов называется \emph{бифунктором}.
\end{definition}

\begin{definition}
  Пусть $\mathcal{C}$ и $\mathcal{D}$~--- категории, а $\mathbf{F}$ и $\mathbf{G}$~--- функторы из $\mathcal{C}$ в $\mathcal{D}$. \emph{Естественным преобразованием} (\eng{natural transformation}) $$\eta : \mathbf{F}~\dot{\to}~\mathbf{G}$$ называется отображение, каждому $\mathcal{C}$-объекту $A$ назначающая $\mathcal{D}$-морфизм $\eta_A : \mathbf{F}(A) \to \mathbf{G}(A)$ такой, что для каждого $\mathcal{C}$-морфизма $f : A \to B$ диаграмма на рисунке \ref{cd:nattrans} коммутирует в категории $\mathcal{D}$.
\end{definition}

\begin{figure}[h]
  \centering
    \begin{tikzcd}
      \mathbf{F}(A) \rar{\eta_A} \dar[swap]{\mathbf{F}(f)} & \mathbf{G}(A) \dar{\mathbf{G}(f)} \\
      \mathbf{F}(B) \rar{\eta_B} & \mathbf{G}(B)
    \end{tikzcd}
    \caption{Коммутативная диаграмма естественного преобразования $\eta$.}
    \label{cd:nattrans}
\end{figure}

\begin{definition}
  Если соответствующий каждому объекту $A$ категории $\mathcal{C}$ морфизм $\eta_A$ является изоморфизмом в категории $\mathcal{D}$, $\eta$ называется \emph{естественным изоморфизмом} (\eng{natural isomorphism}).
\end{definition}

Примечательным свойством является то, что для любых категорий $\mathcal{C}$ и $\mathcal{D}$ функторы между ними образуют категорию с морфизмами, заданными естественными преобразованиям.

\subsection{Моноидальные категории}
\begin{definition}
  Категория $\mathcal{C}$ называется \emph{моноидальной}, если для неё определены
  \begin{enumerate}
    \item Бифунктор $\otimes : \mathcal{C} \times \mathcal{C} \to \mathcal{C}$ (называемым \emph{тензорным} или \emph{моноидальным произведением}).
    \item Объект $I$, называемый \emph{единичным объектом} (\eng{unit object}).
    \item Три естественных изоморфизма $\alpha$, $\lambda$ и $\rho$, удовлетворяющих коммутативным диаграммам на рисунках \ref{cd:alpha} и \ref{cd:lambdarho}, которые выражают, что
      \begin{enumerate}
        \item Тензорное произведение ассоциативно: $(A \otimes B) \otimes C = A \otimes (B \otimes C)$.
\begin{figure}[h]
  \centering
    \begin{tikzcd}
      (((A \otimes B) \otimes C) \otimes D) \dar{\alpha_{A, B, C} \otimes D} \rar{\alpha_{A \otimes B, C, D}} & (A \otimes B) \otimes (C \otimes D) \arrow{dd}{\alpha_{A, B, C \otimes D}} \\
      (A \otimes (B \otimes C)) \otimes D \dar{\alpha_{A, B \otimes C, D}} & \\
      A \otimes ((B \otimes C) \otimes D) \rar{A \otimes \alpha_{B, C, D}} & A \otimes (B \otimes (C \otimes D))
    \end{tikzcd}
%     \begin{tikzpicture}[commutative diagrams/every diagram]
% \node (P0) at (90:2.8cm) {$(((A \otimes B) \otimes C) \otimes D)$};
% \node (P1) at (90+72:2.5cm) {$(A \otimes (B \otimes C)) \otimes D$} ;
% \node (P2) at (90+2*72:2.5cm) {\makebox[5ex][r]{$A \otimes ((B \otimes C) \otimes D)$}};
% \node (P3) at (90+3*72:2.5cm) {\makebox[5ex][l]{$A \otimes (B \otimes (C \otimes D))$}};
% \node (P4) at (90+4*72:2.5cm) {$(A \otimes B) \otimes (C \otimes D)$};
% \path[commutative diagrams/.cd, every arrow, every label]
% (P0) edge node[swap] {$\alpha_{A, B, C} \otimes D$} (P1)
% (P1) edge node[swap] {$\alpha_{A, B \otimes C, D}$} (P2)
% (P2) edge node {$A \otimes \alpha_{B, C, D}$} (P3)
% (P4) edge node {$\alpha_{A, B, C \otimes D}$} (P3)
% (P0) edge node {$\alpha_{A \otimes B, C, D}$} (P4);
% \end{tikzpicture}
    \caption{Коммутативная диаграмма естественных изоморфизмов $\alpha$.}
    \label{cd:alpha}
\end{figure}
        \item $I$ является нейтральным элементом слева и справа относительно тензорного произведения: $A \otimes I = I \otimes A = A$.
\begin{figure}[h]
  \centering
    \begin{tikzcd}[column sep=small]
      (A \otimes I) \otimes B \arrow{rr}{\alpha_{A, I, B}} \arrow{rd}[swap]{\rho_A \otimes B} & & A \otimes (I \otimes B) \arrow{ld}{A \otimes \alpha_B} \\
       & A \otimes B &
    \end{tikzcd}
    \caption{Коммутативная диаграмма естественных изоморфизмов $\lambda$ и $\rho$.}
    \label{cd:lambdarho}
\end{figure}
      \end{enumerate} 
  \end{enumerate}
\end{definition}

Исключив из определения моноидальной категория существование единичного объекта можно получить определение \emph{полумоноидальной категории}.

\subsection{Приложения в теории языков программирования}
Рассмотрим $\mathcal{H}ask$, категорию типов и функций языка Haskell. В ней
\begin{enumerate}
  \item Объектами являются типы (\<String\>, \<[Int]\>, \<String \to Int\>).
  \item Морфизмами являются функции (\<head\>, \<tail\>, \<show\>).
  \item Композицией морфизмов является композиция функций \<(\circ)\>.
  \item Тождественным морфизмом является тождественная функция \<id\>.
  \item Подкатегориями являются, например, все типы, образованные применением какого-либо типового конструктора (такого как \<Maybe\>, \<[]\> или \<Either String\>).
  \item Каждый типовый конструктор \<f\>, конструктор данных \<F : \alpha \to f \alpha\> и функция \<map\> с типом \<f (\alpha \to \beta) \to f \alpha \to f \beta\> задают функтор из \<\mathcal{H}ask\> в подкатегорию \<\mathcal{H}ask\>, задаваемую \<f\>.
  \item Единственным эндофунктором является тождественный эндофунктор, задаваемый функцией \<id\>.
  \item Функция \<listToMaybe :: [a] \to Maybe a\> является примером естественного преобразования $\eta: \mathbf{F} \dot{\to} \mathbf{G}$ между функторами $\mathbf{F}: \mathcal{H}ask \to \mathcal{L}st$ и $\mathbf{G}: \mathcal{H}ask \to \mathcal{M}aybe$.
  \item $\mathcal{H}ask$ является моноидальной категорией с бифунктором, задаваемым типом кортежа из двух элементов и единичным объектом \<()\>. 
\end{enumerate}

Аналогичным образом можно построить $\mathcal{S}cal$~--- категорию типов и функций языка Scala. Строго говоря, в обоих случаях рассматривается лишь некоторое пригодное для формализации подмножество языков\cite{Danielsson2006}.

\chapter{Средства реализации}
\section{Язык программирования Scala}
Scala\cite{Odersky2004} представляет собой промышленный объектно-ориентирован\-ный и функциональный язык программирования со строгой статической типизацией и возможностью вывода типов. Scala компилируется в байт-код JVM и обращение к библиотечным функциям Java.

Scala был выбран в качестве основного языка разработки в этой работе. В данной главе рассматриваются основные затронутые возможности языка.

По сравнению с Java, Scala содержит множество элементов, относящихся к функциональному программированию. Среди них
\begin{enumerate}
  \item Строгое разделение изменяемых и неизменяемых переменных. Переменные, отмеченные как \<\hskwd{var}\> доступны как для чтения, так и модификации, в то время как \<\hskwd{val}\>-переменные нельзя изменить после инициализации.
  \item Поддержка $\lambda$-функций и функций высшего порядка.
  \item Поддержка алгебраических типов данных (\eng{algebraic data types}) и сопоставления с образцом (\eng{pattern matching}).
\end{enumerate}

Scala является объектно-ориентированным языком, основными конструкциями которого являются классы, абстрактные классы и трейты. Последние являются расширением интерфейсов в Java, допуская частичную реализацию и основанное на миксинах (\eng{mixin}) наследование, что позволяет избежать проблем с множественным наследованием, присущим другим языкам. 

Поддерживается т.н. неявную (\eng{impicit}) область видимости. Все значения, объявленные в ней (с помощью ключевого слова \<\hskwd{implicit}\>) могут быть автоматически подставлены в аргументы вызова функции, также помеченных как \<\hskwd{implicit}\>. Эта возможность используется, например, для упрощения API, когда значение, используемое в вызовах нескольких функций (например, кодировка) может быть объявлено один раз и автоматически подставлено в всех необходимых местах.

Scala обладает развитой системой типов. В частности, доступен вывод типов и типы высшего порядка (\eng{higher-kinded types}). Implicit-функции используются для реализации \emph{неявного приведения типов} (\eng{implicit conversion}).

Scala обладает развитым C-подобным синтаксисом со множеством синтаксического сахара. К примеру, специальный символ \<\_\> используется для упрощения синтаксиса $\lambda$-функций, вместо выражения \<x \Rightarrow x + 1\> допустимо писать \<\_ + 1\>. Любой метод объекта может быть использован в инфиксной форме. В некоторых случаях допустимо опускать операторные скобки у блочного аргумента функции и писать \<foo \{ bar(); baz() \}\> вместо \<foo(\{ bar(); baz() \})\>, что активно используется при построении библиотек и встраиваемых языков.

\section{Средства метапрограммирования}
В 2011 году в Scala появились средства для метапрограммирования. Первый технический отчёт\cite{Burmako2012} представлял реализацию макро-системы под названием \<def\>-макросы. 

Наличие в Scala статической системы типов, системы аннотаций и различных сортов синтаксического сахара даёт пространство для прочих модификаций макро-системы. В 2012 году эксперименты продолжились и в отдельной ветке компилятора появились macro flavors\cite{Burmako2013}~--- макро-системы для различных частей языка. В частности, доступны:
\begin{enumerate}
  \item \textbf{Динамические макросы.} Начиная с версии 2.9, Scala позволяет переписывать операции над несуществующими полями и вызовы несуществующих методов у объектов, наследующих трейт \<Dynamic\> в вызовы методов \<selectDynamic\>, \<updateDynamic\> и \<applyDynamic\>. Динамические макросы позволяют переопределить эти макросы в виде макро-определений и генерировать код при необходимости.
  \item \textbf{Implicit-макросы} являются обыкновенными \<def\>-макросами с \begin{otherlanguage}{english}implicit\end{otherlanguage}-аннотацией, что позволяет использовать их как implicit-методы. В данный момент основным сценарием использования implicit-макро\-сов является возможности автоматической материализации реализаций классов типов.
  \item \textbf{Типовые макросы} являются в некотором смысле макросистемой на уровне типов. Встретив использование макро-типа, компилятор раскрывает его в некоторый другой тип, возможно сгенерировав при этом определение необходимого класса.
  \item \textbf{Макро-аннотации} концептуально похожи на типовые макросы и предназначены для увеличения модульности компилятора, в частности, с помощью перевода реализации ленивых значений и \<\hskwd{case}\>-класс в стандартную библиотеку в виде макросов.
  \item \textbf{Нетипизированные макросы.} В отличии от \<def\>-макросов, принимают на вход нетипизированное синтаксическое дерево (т.е. не содержащее меток типов у узлов дерева) и могут проверить тип всего выражения или некоторого подвыражения позже. Следствием этого является то, что нетипизированный макрос может принимать на вход некорректный Scala-код (синтаксически корректный, но не проходящий проверку типов), но модифицирующий его так, что он становится корректным.
\end{enumerate}

Для реализации синтаксического расширения, представляемого в этой работе, используются нетипизированные макросы. Для разработки синтаксического расширения они предоставляют готовый синтаксис языка (уже разобранное синтаксическое дерево), систему типов и доступ к тайп-чекеру и рефлексии, т.е. фактически неограниченный доступ к манипулициям с интерпретацией выражений языка.

\chapter{Функторы и идиомы}
\section{Обзор}
Понятие \emph{функтора}, применительно к программированию, было впервые введено, вероятно, М.~Джонсом\cite{Jones1993a}. В Haskell оно задаётся как класс типов с единственным методом \<map\>, применяющий чистую функцию к содержимому контейнера.

\begin{haskell*}
\hskwd{class} Functor f \hskwd{where} \\
\quad\quad fmap :: (\alpha \to \beta) \to f \alpha \to f \beta
\end{haskell*}

Аналогичное определение в Scala состоит из трейта с одним методом.

\begin{haskell}
\hskwd{trait} Functor[F[\_]] \{ \\
\quad\quad \hskwd{def} fmap[A, B](f:A \Rightarrow B):F[A] \Rightarrow F[B] \\
\}
\end{haskell}

\emph{Аппликативный функтор} (или \emph{идиома}, \eng{idiom}) был предложен МакБрайдом и Паттерсоном\cite{McBride2008} для описания эффективных вычислений в аппликативном стиле.

\begin{haskell*}
\hskwd{class} Functor f \Rightarrow Applicative f \hskwd{where} \\
\hsalign{
  \quad\quad pure &:: \alpha \to f \alpha \\
  \quad\quad (\circledast) &:: f (\alpha \to \beta) \to f \alpha \to f \beta
}
\end{haskell*}

Его аналог в Scala:

\begin{haskell}
\hskwd{trait} Applicative[F[\_]] \hskwd{extends} Functor[F] \{ \\
\quad\quad \hskwd{def} pure[A](a:A):F[A] \\
\quad\quad \hskwd{def} app[A, B](f:F[A \Rightarrow B]):F[A] \Rightarrow F[B] \\
\}
\end{haskell}

Аппликативный функтор является обобщением функтора для функции от нескольких аргументов. \<fmap\> можно выразить с помощью \<pure\> и \<\circledast\> в виде \<fmap f a = pure f \circledast a\>.

\section{Приложения в языках программирования}\label{subsec:idioms-app}
Многие встроенные конструкторы типов функциональных языков программирования поддерживают реализацию функтора и идиомы.

Так, реализация типа, представляющего наличие или отсутствие результата вычисления выглядит в Haskell следующим образом.

\begin{haskell}
\hskwd{instance} Applicative Maybe \hskwd{where}\\
\quad{pure = Just}\\
\quad\hsalign{
(Just f) &\circledast (Just x) &= Just (f x) \\
\_       &\circledast \_       &= Nothing
}
\end{haskell}

Его аналог в Scala выглядит как

\begin{haskell}
\hskwd{val} option = \hskwd{new} Applicative[Option] \{ \\
\quad\hskwd{def} pure[A](a:A) = Some(a)\\
\quad\hskwd{def} app[A, B](f:Option[A \Rightarrow B]) = \\
\quad\quad{x} \Rightarrow (f, a) \hskwd{match} \{\\
\quad\quad\quad\hskwd{case} (Some(g), Some(a)) \Rightarrow Some(f(a))\\
\quad\quad\quad\hskwd{case} \_ \Rightarrow None\\
\quad\quad\}\\
\}
\end{haskell}

Реализация функтора и идиомы позволяет безопасно работать с результатом вычисления, которое могло завершиться неудачей. В отличии языков, использующих \<null\>-значения для описания отсутствия результата (и производящих ошибку времени исполнения при попытке работы с ними), языки с закодированными в типе эффектами гарантируют, что некорректное значение будет обработано. Так, имея функцию \<add\>, суммирующую три своих целочисленных аргумента

\begin{haskell}
add :: Int \to Int \to Int \\
add x y z = x + y + z
\end{haskell}
\hspace{0cm}можно применять её к значениям, содержащим, или не содержащим целое число: 
\begin{haskell}
pure add \circledast Just 3 \circledast Just 2 \circledast Just 5
\end{haskell}

Конструктор типа может иметь и несколько реализаций эффекта. В частности, для списка определяют и реализацию идиомы, методом \<\circledast\> строящую список из всех комбинаций элементов списка и реализацию, известную как \<zipList\>, строящую список из поэлементно взятых пар значений списка.

В данной работе понятие функтора и идиомы используется, в первую очередь, в контексте вычислений с эффектами, хотя построенные реализации полезны и сами по себе. Рассмотрим реализацию идиомы для списка. С одной стороны, \<fmap\>~--- полезная функция, позволяющая применить операцию к каждому элементу списка, а \<\circledast\>~--- для комбинирования всех элементов нескольких списков. С другой~--- список традиционно используется для представления результатов недетерминированных вычислений, и в этом смысле методы функторов можно рассматривать в роли комбинаторов, связывающих чистые и эффективные вычисления. \<fmap\> соответствует композиции недетерминированного и чистого вычисления, чистая функция применяется к каждому из исходов недетерминированного вычисления, в результате чего получается новое недетерминированное значение. \<\circledast\> соответствует композиции нескольких недетерминированных вычислений, чей результат строится из возможных исходов всех недетерминированных аргументов.

Иногда рассматривают аппликативный функтор без оператора \<pure\>. Он определён, к примеру, как класс типов \<Apply\> в пакете \texttt{semigoupoids} Эдварда Кхметта и библиотеке \texttt{scalaz}. Далее на него будем ссылаться как на <<полуидиому>>.

Поскольку идиома является частным случаем функтора, существуют функторы, не являющиеся идиомами. Пример такого функтора~--- пара с зафиксированным первым аргументом. Можно определить операцию \<fmap\>, применяющий функцию ко второму элементу и не затрагивающую первый, но для реализации \<pure\> и \<\circledast\> необходима нотация для пустого значения и композиции значений типа первого элемента. Построить объект идиомы для пары можно, наложив дополнительное ограничение на соответствие интерфейсу моноида для первого элемента. Также можно построить объект полуидиомы, наложив ограничение на соответствие интерфейсу полугруппы.

\section{Теоретико-категорные основания}
Как и подсказывает название, \<Functor f\> формализуется функтором из категории $\mathcal{H}ask$ ($\mathcal{S}cal$) в подкатегорию, задаваемую типовым конструктором \<f\>. Так, к примеру, реализация функтора для списка является функтором из категории $\mathcal{H}ask$ ($\mathcal{S}cal$) в категорию $\mathcal{L}st$, объектами которой являются списочные типы вида \<[\alpha]\>, а морфизмами являются функции над списочными типамим вида \<[\alpha] \to [\beta]\>. Строго говоря, функция \<fmap\> определяет отображением между морфизмами категорий, а в роли отображения между объектами выступает конструктор данных \<F : f \alpha\>, соответствующий конструктору типа. Обычно считается, что он всегда определён.

Законы следуя формальному определению, все реализации функторов должны удовлетворять следующим законам:
\begin{enumerate}
  \item Закон тождества.\\ \<fmap id \equiv id\>
  \item Закон композиции.\\ \<fmap (p \circ q) \equiv (fmap p) \circ (fmap q)\>
\end{enumerate}

И в Haskell, и в Scala реализация функтора должна сама обеспечивать выполнимость этих законов, никакой языковой поддержки для верификации не предоставляется. При этом примечательно, что выполнимость закона композиции следует напрямую из закона тождества, согласно сигнатуре типа функции \<fmap\> и \<(\circ)\>, что гарантируется Вадлеровскими <<бесплатными теоремами>>\cite{Wadler1989a}.

Аппликативный функтор \<Applicative f\> задаётся как слабый моноидальный эндофунктор (\eng{lax monoidal endofunctor}) в категории $\mathcal{H}ask$ ($\mathcal{S}cal$). Рассмотрим это определение.

\begin{definition}
  \emph{Слабый моноидальный функтор} между моноидальными категориями $(\mathcal{C}, \otimes, I, \lambda, \rho, \alpha)$ и $(\mathcal{C'}, \otimes', I', \lambda', \rho', \alpha')$ состоит из функтора $\mathbf{F}: \mathcal{C} \to \mathcal{C'}$ и двух естественных преобразований:
  \begin{enumerate}
    \item $u : I' \to \mathbf{F}(I)$
    \item $\circledast : \mathbf{F}(A) \otimes' \mathbf{F}(A) \to \mathbf{F}(A \otimes B)$
  \end{enumerate}
  таких, что диаграммы на рисунках \ref{cd:monfunc-1}, \ref{cd:monfunc-2} (определяющих, что $u$ является нейтральным элементом слева и справа относительно операции $\circledast$) и \ref{cd:monfunc-3} (определяющей ассоциативность $\circledast$) коммутируют.
\end{definition}

\begin{figure}[h]
  \centering
    \begin{tikzcd}
      I \otimes \mathbf{F}(A) \rar{\lambda} \dar[swap]{u~\otimes~\mathbf{F}(A)} & \mathbf{F}(A) \\
      \mathbf{F}(I) \otimes \mathbf{F}(A) \rar{\circledast} & \mathbf{F}(I \otimes A) \uar[swap]{\mathbf{F}(\lambda)}
    \end{tikzcd}
    \caption{Коммутативная диаграмма естественного преобразования $\lambda$.}
    \label{cd:monfunc-1}
\end{figure}

\begin{figure}[h]
  \centering
    \begin{tikzcd}
      \mathbf{F}(A) \otimes I \rar{\rho} \dar[swap]{\mathbf{F}(A)~\otimes~u} & \mathbf{F}(A) \\
      \mathbf{F}(A) \otimes \mathbf{F}(I) \rar{\circledast} & \mathbf{F}(A \otimes I) \uar[swap]{\mathbf{F}(\rho)}
    \end{tikzcd}
    \caption{Коммутативная диаграмма естественного преобразования $\rho$.}
    \label{cd:monfunc-2}
\end{figure}

\begin{figure}[h]
  \centering
    \begin{tikzcd}
      \mathbf{F}(A) \otimes (\mathbf{F}(B) \otimes \mathbf{F}(C)) \dar[swap]{\mathbf{F}(A)~\otimes~\circledast} \rar{\alpha} & (\mathbf{F}(A) \otimes \mathbf{F}(B)) \otimes \mathbf{F}(C)\dar[swap]{\circledast~\otimes~\mathbf{F}(C)} \\
      \mathbf{F}(A) \otimes \mathbf{F}(B \otimes C) \dar[swap]{\circledast} & \mathbf{F}(A \otimes B) \otimes \mathbf{F}(C) \dar[swap]{\circledast} \\
      \mathbf{F}(A \otimes (B \otimes C)) \rar{\mathbf{F}(\alpha)} & \mathbf{F}((A \otimes B) \otimes C)
    \end{tikzcd}
    \caption{Коммутативная диаграмма естественного преобразования $\alpha$.}
    \label{cd:monfunc-3}
\end{figure}

Аналогично экземплярам функторов, экземпляры аппликативных функторов обязаны подчиняться следующим законам:
\begin{enumerate}
  \item Закон тождества.\\ \<pure id \circledast v \equiv v\>
  \item Закон композиции.\\ \<pure (\circ) \circledast u \circledast v \circledast w \equiv u \circledast (v \circledast w)\>
  \item Закон гомоморфизма.\\ \<pure f \circledast pure x \equiv pure (f x)\>
  \item Закон перестановки.\\ \<u \circledast pure y \equiv pure (\$ y) \circledast u\>
\end{enumerate}

Полуидиоме соответствует слабый \emph{полу-}моноидальный эндофунктор(т.е. определённый в полумоноидальной категории).

\section{Синтаксические расширения}
В оригинальной статье МакБрайда и Паттерсона\cite{McBride2008}, посвящённой аппликативным функторам, приводится нотация \emph{идиоматических скобок} (\eng{idiom brackets}), упрощающая синтаксис применения чистой функции к эффективным аргументам. Так, вместо канонической формы записи в виде
\begin{haskell}
  pure f \circledast u_1 \circledast \dotsc \circledast u_n
\end{haskell}

запись с идиоматическими скобками имеет вид

\begin{haskell}
  \llbracket f u_1 \dotsc u_n \rrbracket.
\end{haskell}

Существует несколько реализаций этой нотации в различных языках. В Haskell она может быть частично реализована с помощью специального класса типов \<Idiomatic\> и вспомогательных алгебраических типов.

Препроцессор Strathclyde Haskell Enhancement\cite{mcbride2009strathclyde} для \begin{otherlanguage}{english}Glasgow Has\-kell Compiler\end{otherlanguage}\cite{jones1993glasgow} предоставляет нотацию вида \<(| f a_1 \dotsc a_n |)\>. В качестве функции допустимо использовать инфиксный оператор. Кроме того, для идиом, реализующих класс типов \<Alternative\>\cite{yorgey2009typeclassopedia} (интерфейс аппликативного функтора, расширенный интерфейсом моноида) допустим синтаксис вида \<(| idiom_1 | idiom_2 | \dotsc | idiom_n |)\>, выбирающий первое встреченное не\-пустое значение среди \<idiom_k\>.

В Idris реализован свой вариант идиоматических скобок\cite{Brady2013a}, состоящий из конструкций \<\hskwd{idiom}\> и \<[| expr |]\>. Аргументами в \<\hskwd{idiom}\> передаются функции, соответствующие методам \<pure\> и \<\circledast\>, а также блок кода, в котором конструкции \<[| expr |]\> будут заменены на вызовы переданных функций.

Специального синтаксиса для простых функторов представлено не было. Конечно, имея реализацию идиомы можно в некоторых случаях использовать идиоматические скобки для функции от одного аргумента (что соответствует функтору). Правда, сгенерирована по прежнему будет пара вызовов \<pure\> и \<\circledast\> (вместо достаточного вызова \<map\>).

Аппликативные функторы и идиоматические скобки формализуют понятие \emph{поднятия} (\eng{lifting}) в математике\cite{Hinze}. Такая нотация широко используется, например, для композиции функционалов в анализе: $$(f + g)(x) = f(x) + g(x).$$

Следует отметить ряд ограничений нотации идиоматических скобок.
\begin{enumerate}
  \item Поддерживается только применения одной чистой функции, поддержки вложенных функций нет. Так, запись \<\llbracket Just 2 + Just 3 \rrbracket\> корректна, а \<\llbracket Just 2 + Just 3 + Just 5 \rrbracket\> уже нет, т.к. это вложенный вызов функции сложения.

  \item В вызове чистой функции ожидаются только эффективные аргументы, нельзя смешивать чистые и эффективные вычисления. Strathclyde Haskell Enhancement допускает специальный синтаксис, аргумент с префиксом $\thicksim$ оборачивается в вызов \<pure\>, но так или иначе вызов \<map\> не генерируется ни в каком случае.

  \item Идиоматические скобки рассчитаны на вычисления в идиомах, но в действительности они они могут работать и с полуидиомами, более слабом контексте. Вызов функции от одного аргумента может транслироваться в вызов \<map\>, а от двух и более~--- в последовательность из \<map\> и \<\circledast\>, вызов \<pure\> не требуется нигде. Таким образом, предлагаемая в работе МакБрайда и Паттерсона нотация затрагивает больший интерфейс, чем требуется.
\end{enumerate}

\section{Расширение \texttt{scala-workflow}}
Результатом работы является разработанное расширение Scala, устраняющее рассмотренные выше ограничения специального синтаксиса вычислений с аппликативными функторами (а также специального синтаксиса для работы с монадами, рассматриваемыми далее). Исходный код расширения, названного \texttt{scala-workflow}, открыт и доступен для загрузки по адресу \url{https://github.com/aztek/scala-workflow}.

\subsection{Иерархия вычислительных контекстов}
Взамен формализации эффекта какой-либо заданной структурой, предлагается более модульный подход. Сила вычислительного контекста наращивается инкрементально добавлением новых методов к пустому базовому трейту \<Workflow\>, в качестве аргумента принимающего конструктор типа.

\begin{haskell}
\hskwd{trait} Workflow[F[\_]] \\
\end{haskell}

Методы добавляются с помощью миксинов соответствующих трейтов, отнаследованных от \<Workflow\>. Так, каждому из рассмотренных ранее методов соответствует свой трейт.

\begin{haskell}
\hskwd{trait} Pointing[F[\_]] ~\hskwd{extends} Workflow[F] \{ \\
\quad\quad \hskwd{def} point[A](a:A):F[A] \\
\} \\
\end{haskell}

\begin{haskell}
\hskwd{trait} Mapping[F[\_]] ~\hskwd{extends} Workflow[F] \{ \\
\quad\quad \hskwd{def} map[A, B](f:A \Rightarrow B):F[A] \Rightarrow F[B] \\
\} \\
\end{haskell}

\begin{haskell}
\hskwd{trait} Applying[F[\_]] ~\hskwd{extends} Workflow[F] ~\hskwd{with} Mapping[F] \{ \\
\quad\quad \hskwd{def} app[A, B](f:F[A \Rightarrow B]):F[A] \Rightarrow F[B] \\
\} \\
\end{haskell}

Объявить реализацию вычислительного контекста можно создав объект \<Workflow\> с подмешанными трейтами и переопределёнными методами, либо воспользовавшись шорткатом, представляющим одну из рассмотренных структур (важно, что это не самостоятельные определения, а просто синонимы для подмешиваемого набора трейтов).

\begin{haskell}
\hskwd{trait} Functor[F[\_]] ~\hskwd{extends} Mapping[F]
\end{haskell}

\begin{haskell}
\hskwd{trait} SemiIdiom[F[\_]] ~\hskwd{extends} Functor[F] ~\hskwd{with} Applying[F]
\end{haskell}

\begin{haskell}
\hskwd{trait} Idiom[F[\_]] ~\hskwd{extends} SemiIdiom[F] ~\hskwd{with} Pointing[F] \{\\
\quad\quad \hskwd{def} map[A, B](f:A \Rightarrow B) = app(point(f))\\
\}
\end{haskell}

\subsection{Алгоритм раскрытия выражений}
Одно из важных отличий \texttt{scala-workflow} от похожих синтаксических расширений заключается в том, что оно всегда стремится использовать наименее мощный интерфейс реализации вычислительного контекста для сгенерированного кода. Это означает, в частности, что появляется возможность пользоваться идиоматическими скобками для функторов (например, для \<Map[A, B]\>).

Реализация \texttt{scala-workflow} основана на нетипизированных макросах. Макрос $\$$ принимает в качестве аргумента синтаксическое дерево выражения на Scala. Это выражение обязано быть синтаксически корректным, но не обязано проходить проверку типов.

Алгоритм раскрытия выражений для контекста \<Workflow[F]\> начинает проверять типы всех подвыражений, начиная с наиболее вложенных. В зависимости от результата проверки:
\begin{enumerate}
  \item Если проверка типов завершилась успешно и результирующий тип равен \<F[T]\> для какого-то \<T\>, выражение заменяется на синтетический параметр \<x_n\> типа \<T\> и связывание \<x_n\> с реальным значением запоминается в отдельную таблицу.
  \item Если проверка типов завершилась успешно и результирующий тип соответствует чистому значению (в заданном контексте), выражение оставляется как есть.
  \item В противном случае, алгоритм разбивает выражение на составные части и пытается переписать их.
\end{enumerate}

Алгоритм останавливается, когда переписанное выражение проходит проверку типов. На выходе остаётся таблица связываний синтетических параметров. Далее, все появившиеся в ней синтетические имена переменных генерируются в определения аргументов анонимных функций, а эффективные значения~--- в аргументы вызовов методов контекста.

Рассмотрим следующий пример.

\begin{haskell}
context(option) \{ \\
\quad\quad \$(2 \times 3 + Some(10) \times Some(5)) \\
\}
\end{haskell}

Все числа проходят проверку типов и результирующий тип равен \<Int\>, поэтому они оставляются как есть. \<2 \times 3\> так же проходит проверку типов и оставляется как есть. \<Some(10)\> и \<Some(5)\> оба проходят проверку типов с результирующим типом \<Option[Int]\> (вообще говоря, в данном случае они имеют тип \<Some[Int]\>, что тоже допустимо, поскольку проверка происходит не на равенство типов а на отношение подтипизации), поэтому в таблицу связываний синтетических параметров добавляется две записи.

Сгенерированный код выглядит следующим образом.

\begin{haskell}
option.app( \\
\quad\quad option.map( \\
\quad\quad\quad (x_1:Int) \Rightarrow (x_2:Int) \Rightarrow \\
\quad\quad\quad\quad 2 \times 3 + x_1 \times x_2 \\
\quad\quad )(Some(10)) \\
)(Some(5))
\end{haskell}

%А результат его работы равен 56.

Стоит отметить, что метод \<point\> генерируется только когда в скобки передано корректное чистое значение. Во всех остальных случаях будут сгенерированы вызовы \<map\> и \<app\>. В таблице \ref{table:idiom-rewrite} приводятся примеры $\$$-выражений и результат их раскрытия.

\begin{table}[h]\small

\begin{tabularx}{\textwidth}{|X|X|}

\hline

\textbf{\$-выражение} & \textbf{Раскрытое выражение} \tabularnewline

\hline

\<\$(42)\> & \<option.point(42)\> \tabularnewline

\hline

{\vspace{-15pt}\<\$(Some(42) + 1)\>}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.map( \\
\quad (x_1:Int) \Rightarrow \\
\quad\quad x_1 + 1 \\
)(Some(42))
\end{haskell}\vspace*{-22pt}\end{minipage}} \tabularnewline

\hline

{\vspace{-15pt}\<\$(Some(2) \times Some(3))\>}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.app( \\
\quad option.map( \\
\quad\quad (x_1:Int) \Rightarrow (x_2:Int) \Rightarrow \\
\quad\quad\quad x_1 \times x_2 \\
\quad )(Some(2)) \\
)(Some(3))
\end{haskell}\vspace*{-22pt}\end{minipage}} \tabularnewline

\hline

{\vspace{-15pt}\<\$(Some(2) \times Some(3) + Some(5))\>}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.app( \\
\quad option.app( \\
\quad\quad option.map( \\
\quad\quad\quad (x_1:Int) \Rightarrow (x_2:Int) \Rightarrow (x_3:Int) \Rightarrow \\
\quad\quad\quad\quad x_1 \times x_2 + x_3 \\
\quad\quad )(Some(2)) \\
\quad )(Some(3)) \\
)(Some(5))
\end{haskell}\vspace*{-22pt}\end{minipage}} \tabularnewline

\hline

\end{tabularx}
\caption{Примеры раскрытия $\$$-выражений}
\label{table:idiom-rewrite}
\end{table}

\subsection{Определение контекста}
Вычислительный контекст задаётся с помощью макроса \<context\>, который принимает в качестве аргумента либо реализацию контекста, либо конструктор типа \<F[\_]\>, такой, что в области видимости implicit-значений содержится реализация такого контекста.

Так, следующие два примеры эквивалентны. Значение \<list\> определено в качестве implicit-значения внутри \texttt{scala-workflow}.

\begin{haskell}
context[List] \{ \\
\quad\quad \$(List(2, 5) \times List(3, 7)) \\
\} \\
{} \\
context(list) \{ \\
\quad\quad \$(List(2, 5) \times List(3, 7)) \\
\}
\end{haskell}

Макрос $\$$ использует контекст из наиболее близко определённого блока \<context\>. В качестве альтернативы можно указать конструктор типа, соответствующая реализация вычислительного контекста которого будет взята из области видимости implicit-значений.

\begin{haskell}
\$[List](List(2, 5) \times List(3, 7))
\end{haskell}

При таком вызове, $\$$ игнорирует все ограждающие блоки \<context\> и работает внутри контекста \<Workflow[List]\>.

Вложенные применения \<context\> и $\$$ могут быть заменены специальным макросом \<workflow\>, принимающим в качестве аргумента либо реализацию контекста, либо конструктор типа, и переписывающий блок кода по тем же правилам, что и $\$$.

\begin{haskell}
workflow(list) \{ \\
\quad\quad List(2, 5) \times List(3, 7) \\
\}
\end{haskell}

Макрос \<workflow\> рассчитана на работу со сложными фрагментами кода, в то время как $\$$ рассчитана на простые выражения.

Вместе с расширением поставляется набор встроенных реализаций контекста, определённых внутри трейтов \<FunctorInstances\>, \<IdiomInstances\> и \<SemiIdiomInstances\>. Все они подмешаны к объекту пакета \<scala.workflow\> и потому доступны при импорте \<workflow.\_\>. В качестве альтернативы можно импортировать только сами определения макросов
\begin{haskell}workflow.\{context, workflow, \$\}\end{haskell}
\hspace{0cm}и обращаться к реализациям через объекты \<Functor\>, \<SemiIdiom\> и \<Idiom\>.

\subsection{Композиция эффектов}
Известно, что из произвольной пары функторов, полу-идиом и идиом можно построить композицию. Это следует из коммутативности операций над соответствующими алгебраическими структурами. \texttt{scala-workflow} оп\-ределяет набор классов композиции (\<FunctorCompose\>, \<SemiIdiomCompose\> и \<IdiomCompose\> соответственно) позволяющих, например, имея реализации \<Idiom[F]\> и \<Idiom[G]\>, получить реализацию \<Idiom[F[G]]\>. Создать объект класса \<IdiomCompose\> можно либо явно с помощью конструктора класса, либо вызовом метода $\$$ класса \<Idiom\> (а по аналогии, и для других классов, поддерживащих композицию).

\begin{haskell}
context(list \$ option) \{ \\
\quad\quad \$(List(Some(2), Some(3), None) \times 10) == \\
\quad\quad\quad List(Some(20), Some(30), None) \\
\}
\end{haskell}

С помощью этого же синтаксиса возможно комбинировать контексты различных классов, при этом результирующий контекст будет реализовывать более слабый интерфейс из переданных двух. Например, объект \<map[String] \$ option\> реализует \<Functor\>, поскольку из двух переданных контекстов, \<Functor\> у \<map[String]\> и \<Idiom\> у \<option\> первый слабее.

Композиция контекстов некоммутативна, \<list \$ option\> и \<option \$ list\> задают два различных контекста и значения типа \<List[Option[T]]\> будет считаться чистым во втором случае.

\begin{haskell}
context(option \$ list) \{ \\
\quad\quad \$(Some(List(1, 2, 3)) \times 10) == Some(List(10, 20, 30)) \\
\}
\end{haskell}

\section{Приложения}
\subsection{Интерпретатор с обработкой ошибок}
Следуя примеру из \cite{McBride2008} рассмотрим, как \texttt{scala-workflow} упрощает построение интерпретатора с обработкой ошибок. Определение абстрактного синтаксиса языка с целыми числами, связываниями переменных и операцией сложения выглядит следующим образом.

\begin{haskell}
\hskwd{sealed} \hskwd{trait} Expr \\
\hskwd{case} \hskwd{class} Var(id:String) ~\hskwd{extends} ~Expr \\
\hskwd{case} \hskwd{class} Val(value:Int) ~\hskwd{extends} ~Expr \\
\hskwd{case} \hskwd{class} Add(lhs:Expr, rhs:Expr) ~\hskwd{extends} ~Expr
\end{haskell}

Значения переменных хранятся в окружении, заданном типом \<Env\>, фактически являющимся хеш-таблицей. Обращение к окружению происходит с помощью функции \<fetch\>, возвращающей либо значение переменной, либо \<None\>.

\begin{haskell}
\hskwd{type} Env = Map[String, Int] \\
\hskwd{def} fetch(x:String)(env:Env):Option[Int] = env.get(x)
\end{haskell}

Интерпретатор представляет собой функцию, принимающую выражение, объект окружения и возвращающую либо результат вычисления, либо его отсутствие, в случае, когда одна из использованных внутри выражения переменных не задана в окружении. Ниже приводится её реализация с помощью \<\hskwd{for}\>-нотации.

\begin{haskell}
\hskwd{def} eval(expr:Expr)(env:Env):Option[Int] = \\
\quad\quad expr \hskwd{match} \{ \\
\quad\quad\quad \hskwd{case} Var(x) \Rightarrow fetch(x)(env) \\
\quad\quad\quad \hskwd{case} Val(value) \Rightarrow Some(value) \\
\quad\quad\quad \hskwd{case} Add(x, y) \Rightarrow \hskwd{for} \{ \\
\quad\quad\quad\quad lhs \hsfrom eval(x)(env) \\
\quad\quad\quad\quad rhs \hsfrom eval(y)(env) \\
\quad\quad\quad \} \hskwd{yield} lhs + rhs \\
\quad\quad \}
\end{haskell}

Следует отметить, что при таком подходе приходится явно передавать объект окружения в рекурсивный вызов и явно именовать проточные вычисления при интерпретации сложения. Реализация может быть значительно упрощена, будучи помещённой в вычислительный контекст вида \<Workflow[Env \Rightarrow Option[\_]]\>, который может быть построен либо вручную, либо композицией \<Workflow[Env \Rightarrow \_]\> и \<Workflow[Option]\>.

\begin{haskell}
\hskwd{def} eval:Expr \Rightarrow Env \Rightarrow Option[Int] = \\
\quad\quad context(function[Env] ~\$ option) \{ \\
\quad\quad\quad \hskwd{case} Var(x) \Rightarrow fetch(x) \\
\quad\quad\quad \hskwd{case} Val(value) \Rightarrow \$(value) \\
\quad\quad\quad \hskwd{case} Add(x, y) \Rightarrow \$(eval(x) + eval(y)) \\
\quad\quad \}
\end{haskell}

\subsection{Недетерминированные вычисления}
Недетерминированные значения традиционно представляются с помощью списков. Функцию, возвращающую список, можно интерпретировать как функцию, возвращающую суперпозицию из нескольких результатов вычисления.

\begin{haskell}
\hsalign{
\hskwd{val} ~xs &~= List(1, 2, 3) \\
\hskwd{val} ~ys &~= List(4, 5) \\
\hskwd{val} ~zs &~= List(6, 7)
}
\end{haskell}

Поместив блок кода в контекст \<Workflow[List]\> можно прозрачно работать с недетерминированными значениями с помощью $\$$-нотации.

Применение чистой функции к недетерминированному значению должно вызывать её для каждого возможного результата вычисления и собирать полученные значения обратно в список.

\begin{haskell}
\$(xs \times 2) == List(2, 4, 6) \\
\end{haskell}

Вычисления, задействующие два и более недетерминированных значения должны брать комбинации из всех возможных значений и помещать в список все полученные результаты.

\begin{haskell}
\$(xs \times ys) == List(4, 5, 8, 10, 12, 15) \\
\$(xs \times ys + zs) == List(10, 11, 11, 12, 14, 15, 16, 17, 18, 19, 21, 22)
\end{haskell}

\subsection{Асинхронное программирование}\label{subsec:idioms-async}
Многие языки программирования предоставляют интерфейс \<Future\>, предназначенный для организации асинхронных вычислений. Так, запуск вычисления объекта \<Future\> не блокирует поток исполнения, а начинает выполнять код в соседнем потоке, позволяя позже заблокироваться для получения результата. В Scala класс \<Future\> имеет аппликативный интерфейс (а как будет показано далее, и монадический), а потому его можно использовать для асинхронного программирования в идиоматических скобках.

Рассмотрим функцию \<slowly\>, которая блокирует исполнение на секунду, после чего вычисляет свой ленивый аргумент.

\begin{haskell}
\hskwd{def} slowly[A](proc: \Rightarrow A) = \{ \\
\quad{Thread.sleep(1000)}\\
\quad{proc}\\
\}
\end{haskell}

Идиоматические скобки контекста \<Future\> позволяют организовывать вычисления в будущем.

\begin{haskell}
context[Future] \{ \\
\quad\hskwd{val} x = \$(slowly(2 \times 3)) \\
\quad\hskwd{val} y = \$(slowly(4 - 1)) \\
\quad\$(x \times y) \\
\}
\end{haskell}

Переданное в скобки чистое значение (такое как \<slowly(2 \times 3)\>) начинает исполняться асинхронно, а несколько скомбинированных асинхронных значений порождают новое асинхронное значение, ждущее результаты выполнения всех своих аргументов. Приведённый выше код сгенерирует асинхронное значение, результат которого будет доступен примерно спустя секунду после запуска, значения \<x\> и \<y\> будут выполняться параллельно. 

\subsection{$\mathds{SKI}$-исчисление и беcточечная нотация}
У реализации экземпляра идиомы для функции (\<Idiom[A \Rightarrow \_]\>\footnote{Здесь и далее подобная запись выбрана для наглядности и не является корректным кодом на Scala. Правильная запись использует \emph{типовую $\lambda$-функцию} и в данном случае имеет вид \<Idiom[(\{ \hskwd{type}~\lambda[\alpha] = A \Rightarrow \alpha\})\#\lambda]\>.}) есть примечательное свойство. Его методы \<point\> и \<app\> являются, соответственно, комбинаторами $\mathds{K}$ и $\mathds{S}$ в $\mathds{SKI}$-исчислении\cite{curry1972combinatory}. Это означает, что с помощью композиции этих двух методов можно построить любой замкнутый $\lambda$-терм (иными словами, любую функцию). Так, реализация $\mathds{I}$-комбинатора выглядит как
\begin{haskell}
\hskwd{def} ~id[T] = function[T].app( \\
\quad\quad function[T \Rightarrow T].point \\
)(function[T].point)
\end{haskell}

А $\mathds{B}$-комбинатор (соответствующий композиции функций) выражается в виде
\begin{haskell}
\hskwd{def} ~b[A, B, C] = function[A \Rightarrow B].app( \\
\quad\quad function[A \Rightarrow B].point(function[C].app[A, B]) \\
)(function[C].point)
\end{haskell}

У этой идиомы есть и более практическое применение. Она может быть использована для построения функций в бесточечном стиле (англ. \eng{point-free notation}), т.е. без указания аргументов функции.

В качестве примера, рассмотрим идиому \<function[Char]\> и функцию \<isLetterOrDigit\>, определяющую, является символ буквой или цифрой. Имея в распоряжении пару вспомогательных функций
\begin{haskell}
\hsalign{
  \hskwd{val} ~isLetter:&~Char \Rightarrow Boolean = \_.isLetter \\
  \hskwd{val} ~isDigit:&~Char \Rightarrow Boolean = \_.isDigit
}
\end{haskell}
в традиционном стиле её реализация выглядит как
\begin{haskell}
  \hskwd{val} ~isLetterOrDigit = (ch:Char) \Rightarrow isLetter(ch) ~|| ~isDigit(ch)
\end{haskell}

В бесточечном стиле и с применением идиоматических скобок появляется возможность выразить её как
\begin{haskell}
  \hskwd{val} ~isLetterOrDigit = \$(isLetter ~|| ~isDigit)
\end{haskell}

Методы \<Function.compose\> и \<Function.andThen\> могут быть использованы для построения более сложных функций. Так, работая в идиоме \<function[Double]\> можно скомбинировать функции
\begin{haskell}
\hsalign{
  \hskwd{val} ~sqrt:&~Double \Rightarrow Double = x \Rightarrow math.sqrt(x) \\
  \hskwd{val} ~sqr: &~Double \Rightarrow Double = x \Rightarrow x \times x \\
  \hskwd{val} ~log: &~Double \Rightarrow Double = x \Rightarrow math.log(x)
}
\end{haskell}

Следующие пары функций эквивалентны:
\begin{haskell}
  \hskwd{val} ~f = (x:Double) \Rightarrow sqrt((sqr(x) - 1) \div (sqr(x) + 1)) \\
  \hskwd{val} ~f = sqrt ~compose ~\$((sqr - 1) \div (sqr + 1)) \\
  \\ \\ 
  \hskwd{val} ~g = (x:Double) \Rightarrow (sqr(log(x)) - 1) \div (sqr(log(x)) + 1) \\
  \hskwd{val} ~g = log ~andThen ~\$((sqr - 1) \div (sqr + 1))
\end{haskell}

\subsection{Аппликативные EDSL}
Помимо синтаксической поддержки вычислений с эффектами, \texttt{scala\-workflow} также находит приложение и в роли синтаксического фреймворка для \emph{встраиваемых предметно-ориентированных языков} (\eng{embedded domain-specific language}, сокращённо EDSL). Как отмечалось ранее, аппликативные функторы являются не только способом описания эффектов, но и полезным формализмом для прикладного программирования.

В качестве примера рассмотрим построение небольшого встраиваемого языка для \emph{реактивного программирования}\cite{Elliott2009} (\eng{functional reactive programming}). Парадигма реактивного программирования определяет потоки данных с распространением изменения состояния. Классическим примером реактивных вычислений являются электронные таблицы, где изменение значения одной из ячеек влечёт изменение и всех остальных ячеек, зависящих от ней. В контексте Scala реактивное программирование интересно, в частности, в качестве альтернативы шаблону проектирования Observer\cite{Maier2010}.

Интерфейс ячейки предоставляет доступ к значение типа \<T\>. Хранимое значение при этом может зависеть от значений других ячеек. Над ячейкой допустимы две операции: получение содержимого (возможно, сопровождающее пересчётом содержимого других ячеек) и присвоение значения. 

\begin{haskell}
\hskwd{trait} Cell[T] \{\\
\quad\hskwd{def} ! : T\\
\quad\hskwd{def} := (value : T)\\
\}
\end{haskell}

Для ячейки можно объявить реализацию идиомы, идиоматические скобки которой будут позволять комбинировать чистые и реактивные вычисления. Фактически, метод \<point\> создаёт ячейку, хранящую значение и допускающее его изменение, а метод \<app\> создаёт ячейку, обращение к которой провоцирует обращение к значениям всех зависящих ячеек.

\begin{haskell}
\hskwd{val} ~frp = \hskwd{new} Idiom[Cell] \{\\
\quad\hskwd{def} point[A](a : A) = \hskwd{new} Cell[A] \{\\
\quad\quad\hskwd{private} \hskwd{var} value = a\\
\quad\quad\hskwd{def} := (a : A) \{ value = a \}\\
\quad\quad\hskwd{def} ! = value\\
\quad\}\\
\quad\hskwd{def} app[A, B](f : Cell[A \Rightarrow B]) = a \Rightarrow \hskwd{new} Cell[B] \{\\
\quad\quad\hskwd{def} ! = f!(a!)\\
\quad\quad\hskwd{def} := (value : T) \{ \\
\quad\quad\quad\hskwd{throw} \hskwd{new} UnsupportedOperationException\\
\quad\quad\}\\
\quad\}\\
\}
\end{haskell}

Теперь при работе внутри контекста \<Workflow[Cell]\> появляется возможность все реактивные вычисления проводить в идиоматических скобках, а также прозрачно смешивать чистые и реактивные вычисления.

\begin{haskell}
\hsalign{
  context(frp) \{\\ \hsalign{
  \quad\quad &\hskwd{val} a = \mathdollar(10)\\
  \quad\quad &\hskwd{val} b = \mathdollar(5)\\
  \quad\quad &\hskwd{val} c = \mathdollar(a + b \times 2)\\
  \quad\quad &println(c!)\\
  \quad\quad &b := 7\\
  \quad\quad &println(c!)\\
  \}
  }
}
\end{haskell}

Выведет 20 и 24.

\chapter{Монады}
\section{Обзор}
Монады представляют собой ещё один способ формализации эффектов. Термин \emph{монада} был взят из теории категорий, а её связь с вычислениями показал Могги\cite{Moggi1991}. Вадлер описал\cite{Wadler1992,wadler1993monads} применимость монад в функциональном программировании, а наибольшую известность они получили после того, как вошли в Haskell, в частности, в виде формализации подсистемы ввода-вывода\cite{Jones1993}.

Монада представляет собой структуру, состоящую из \emph{монадической единицы} и \emph{монадического связывания}. В Haskell её можно представить в виде класса типов с двумя методами.

\begin{haskell}
\hskwd{class} Monad \mu \hskwd{where} \\
\quad\hsalign{
  return &~:: \alpha \to \mu \alpha \\
  (\hsbind) &~:: \mu \alpha \to (\alpha \to \mu \beta) \to \mu \beta \\
}
\end{haskell}

Аналогичное описание на Scala выглядит как

\begin{haskell}
\hskwd{trait} Monad[M[\_]] \{ \\
\quad\hskwd{def} point[A](a: A):M[A] \\
\quad\hskwd{def} bind[A, B](f:A \Rightarrow M[B]):M[A] \Rightarrow M[B] \\
\}
\end{haskell}

Нетрудно показать, что монада является частным случаем аппликативного функтора (а соответственно, и обычного функтора). Монадическая единица является оператором \<pure\>, а оператор \<\circledast\> можно выразить в виде \<f \circledast x = x \hsbind (\lambda a \to f \hsbind (\lambda g \to  return (g a))) \>.

\section{Приложения в языках программирования}
Монада в Haskell представлена классом типов, концептуально схожим с описанным в предыдущем параграфе. В ней также доступен оператор \<\mathbin{>\mkern-7mu>}\> с типом \<\mu \alpha \to \mu \beta \to \mu \beta\>, представляющий собой аналог \<\hsbind\> для вырожденного случая второго аргумента, не зависящего от результата предыдущего вычисления.

Scala не предоставляет специального интерфейса, описывающего монаду, но содержит ряд соглашений по заданию методов, образующих монадическую структуру. Этими методами являются \<map\> (соответствующий \<fmap\> в Haskell), \<flatMap\> (соответствующий \<\hsbind\>) и \<filter\>, используемый для фильтрации содержимого монады по условию.

Как было сказано ранее, монады являются частным случаем аппликативного функтора. Примером реализации аппликативного функтора, не являющегося монадой, является упомянутый в параграфе \ref{subsec:idioms-app} \<zipList\>.

Тем не менее, большая часть стандартных конструкторов типа обладают реализацией монады. Вновь рассмотрим тип, представляющий наличие или отсутствие значения.

\begin{haskell}
\hskwd{instance} Monad Maybe \hskwd{where}\\
\quad{return = Just}\\
\quad\hsalign{
(Just a) &\hsbind f  &= f a \\
\_       &\hsbind \_ &= Nothing
}
\end{haskell}

Его аналог в Scala выглядит как

\begin{haskell}
\hskwd{val} option = \hskwd{new} Monad[Option] \{ \\
\quad\hskwd{def} point[A](a:A) = Some(a)\\
\quad\hskwd{def} bind[A, B](f:A \Rightarrow Option[B]) = \{\\
\quad\quad\quad\hskwd{case} Some(a) \Rightarrow f(a)\\
\quad\quad\quad\hskwd{case} \_ \Rightarrow None\\
\quad\quad\}\\
\}
\end{haskell}

В качестве примера использования рассмотрим функцию безопасного деления действительных чисел.

\begin{haskell}
divide :: Double \to Maybe Double \\
\hsalign{
divide \_ 0 ~&= Nothing \\
divide x y  ~&= Just (x \div y)
}
\end{haskell}

С помощью монады для \<Maybe\> можно строить сложные вычисления с эффектами. Так, функция, безопасно вычисляющая значение выражения $1 \div (1 \div x + 1 \div y)$ для аргументов \<x\> и \<y\> может быть построена как

\begin{haskell}
\hsalign{
complexDivide x y = ~& divide(1, x) \hsbind \lambda x' \to \\
                     & divide(1, y) \hsbind \lambda y' \to \\
                     & divide(1, x' + y')
}
\end{haskell}

Все вычисления с использованием аппликативных функторов можно переформулировать для монад. Так, пример со сложением чисел из параграфа \ref{subsec:idioms-app} можно переписать в виде

\begin{haskell}
Just 3 \hsbind \lambda x \to Just 2 \hsbind \lambda y \to Just 5 \hsbind return \$ add x y z
\end{haskell}

Необходимо отметить отличия в выразительной силе монад и идиом.
\begin{enumerate}
  \item Монады вводят нотацию зависимости одного вычисления с эффектами от другого. В предыдущем примере для результатов промежуточных вычислений пришлось вводить имена \<x\>, \<y\>, \<z\>, то время как в аппликативном контексте явного именования не потребовалось, т.ч. в этом смысле монады оказываются более многословными, чем требует постановка задачи. С другой стороны, нотация зависимости между вычислениями позволяет организовывать вычисления, невыразимые в аппликативном контексте, как в определении функции \<complexDivide\>. 

  \item В отличии от функторов и идиом, монады не композируются. Иными словами, имея в общем случае экземпляры монад \<Monad F\> и \<Monad G\> для конструкторов \<F\> и \<G\>, нельзя построить экземпляр \<Monad (F \circ G)\>. Построить композицию\cite{King1993} для двух конкретных экземпляров монад возможно, объявив \emph{трансформер монад}\cite{Liang1995} (\eng{monad transformer}). Также стоит отметить, что монады некоммутативны, т.е. \<Monad (F \circ G)\> и \<Monad (G \circ F)\> являются двумя разными монадами.

  \item При переходе от чистых вычислений к монадическим требуется явно задавать порядок вычислений. Использование стиля \emph{вызова по значению} (\eng{call-by-value}) или \emph{вызова по имени} (\eng{call-by-name}) может приводить к различиям в семантике программы\cite{Petricek2012}). В аппликативных вычислениях эти различия отсутствуют.
\end{enumerate}

\section{Теоретико-категорные основания}

\begin{definition}
  \emph{Монадой} в категории $\mathcal{C}$ называется эндофунктор $\mathbf{T}$ и пара естественных преобразований:
  \begin{enumerate}
    \item $\eta : 1_{\mathcal{C}} \dot{\to} \mathbf{T}$, где $1_{\mathcal{C}}$~--- тождественный функтор категории $\mathcal{C}$
    \item $\mu : \mathbf{T}^2 \dot{\to} \mathbf{T}$, где $\mathbf{T}^2$~--- композиция эндофункторов категории $\mathcal{C}$
  \end{enumerate}
  таких, что диаграммы на рисунке \ref{cd:monad-1} (определяющему, что $\mu_X \circ \mathbf{T}(\mu_X) = \mu_X \circ \mu_{\mathbf{T}(X)}$) и \ref{cd:monad-assoc} (определяющему, что $\mu_X \circ \mathbf{T}(\eta_X) = \mu_X \circ \eta_{\mathbf{T}(X)} = 1_{\mathbf{T}}$) коммутируют.
\end{definition}

\begin{figure}[h]
  \centering
    \begin{tikzcd}
      \mathbf{T}^3(X) \rar{\mathbf{T}(\mu_X)} \dar[swap]{\mu_{\mathbf{T}(X)}} & \mathbf{T}^2(X) \dar{\mu_X} \\
      \mathbf{T}^2(X) \rar{\mu_X} & \mathbf{T}(X)
    \end{tikzcd}
    \caption{Коммутативная диаграмма естественного преобразования $\eta_X$.}
    \label{cd:monad-1}
\end{figure}

\begin{figure}[h]
  \centering
    \begin{tikzcd}
      \mathbf{T}(X) \rar{\eta_{\mathbf{T}(X)}} \dar[swap]{\mathbf{T}(\eta_X)} \arrow[equal]{dr} & \mathbf{T}^2(X) \dar{\mu_X} \\
      \mathbf{T}^2(X) \rar{\mu_X} & \mathbf{T}(X)
    \end{tikzcd}
    \caption{Коммутативная диаграмма естественного преобразования $\mu_X$.}
    \label{cd:monad-assoc}
\end{figure}

<<Категорному>> определение монады соответствует следующее определение в Haskell:
\begin{haskell}
\hskwd{class} Monad \mu \hskwd{where} \\
\quad\hsalign{
  fmap   &~:: (\alpha \to \beta) \to \mu \alpha \to \mu \beta\\
  return &~:: \alpha \to \mu \alpha \\
  join   &~:: \mu (\mu \alpha) \to \mu \alpha
}
\end{haskell}

Здесь метод \<fmap\>, фактически, задаёт функтор, \<return\> задаёт естественное преобразование $\eta$, а \<join\> задаёт естественное преобразование $\mu$. Несложно показать, что <<категорное>> определение эквивалентно <<прикладному>>. Последнее используется, т.к. более удобно на практике. Действительно, \<join x = x \hsbind id\>, а \<x \hsbind f = join (fmap f x)\>.

Реализация монады должна удовлетворять нескольким законам.
\begin{enumerate}
  \item Закон левого тождества. \\ \<return a \hsbind f \equiv f a\>
  \item Закон правого тождества. \\ \<m \hsbind return \equiv m\>
  \item Закон ассоциативности. \\ \<(m \hsbind f) \hsbind g \equiv m \hsbind (\lambda x \to f x \hsbind g)\>
\end{enumerate}

Более интуитивный набор аксиом можно получить, введя операцию \emph{композиции Клейсли}.

\begin{haskell}
(\hskleisli) :: (\alpha \to \mu \beta) \to (\beta \to \mu \gamma) \to \alpha \to \mu \gamma \\
f \hskleisli g = \lambda x \to f x \hsbind g
\end{haskell}

Заменив монадическое связывание на композицию Клейсли получим следующий набор законов.
\begin{enumerate}
  \item \<return\> нейтрален слева. \\ \<return \hskleisli f \equiv f\>
  \item \<return\> нейтрален справа. \\ \<f \hskleisli return \equiv f\>
  \item Композиции Клейсли ассоциативна. \\ \<(f \hskleisli g) \hskleisli h \equiv f \hskleisli (g \hskleisli h)\>
\end{enumerate}

Теперь явно видна моноидальная структура монады~--- ассоциативной операцией является композиция Клейсли, а нейтральным элементом~--- монадическая единица. Фактически, монада является моноидальным объектом в \emph{категории Клейсли}, состоящей из функций вида \<\alpha \to \mu \beta\>.

\section{Синтаксические расширения}
Заняв заметное место в языках программирования, монады получили и более развитый синтаксис в языках программирования. Рассмотрим некоторые из них.

\subsection{Haskell}
Haskell предоставляет два расширения для монад. Первое, \emph{выделение монад}\cite{Wadler1994} (\eng{monad comprehension}) обобщает синтаксис \emph{выделения списков} (\eng{list comprehension}). Оно становится доступно при включении опции \<\{-\# LANGUAGE MonadComprehensions \#-\}\>. С ним, выражения в квадратных скобках, используемые для построения списков
\begin{haskell}
[ x + y | x \hsfrom [1, 2, 3], y \hsfrom [4, 5, 6] ]
\end{haskell}
\hspace{0cm}могут быть обобщены для произвольной монады, такой как \<Maybe a\>
\begin{haskell}
[ x + y | x \hsfrom Just 2, y \hsfrom Just 3 ]
\end{haskell}

Правила раскрытия выражений подробно описаны в \cite{Giorgidze2011}. Помимо связывания эффективных значений поддерживается группировка по условию и <<застёгивание>> (\eng{zipping}) выражений. Приведённое выше выражение раскрывается в

\begin{haskell}
Just 2 \hsbind \lambda x \to \\
\quad\quad Just 3 \hsbind \lambda y \to \\
\quad\quad\quad return (x + y)
\end{haskell}

Второе расширение носит название \<\hskwd{do}\>-нотации. Последовательность из связываний в виде стрелки влево раскрывается во вложенный вызов функции \<\hsbind\>. Так, выражение вычисление суммы комбинаций из всех элементов двух списков выглядит как

\begin{haskell}
\hsdo{
  x \hsfrom [1, 2, 3] \\
  y \hsfrom [4, 5, 6] \\
  return (x + y)
}
\end{haskell}
\hspace{0cm}преобразовывается в
\begin{haskell}
[1, 2, 3] \hsbind \lambda x \to \\
\quad\quad [4, 5, 6] \hsbind \lambda y \to \\
\quad\quad\quad return (x + y)
\end{haskell}

Допустимо не давать имени связыванию (в таком случае имя переменной и стрелка опускаются), что может быть удобно, если эффективное вычисление не производит результата и используется только для побочного эффекта.

Стоит отметить, что, в отличии от выделения монад, \<\hskwd{do}\>-нотация не производит вызова \<return\>, в примере выше \<return (x + y)\> является значением, возвращаемым из выражения.

\subsection{Scala}
Scala предоставляет расширение, известное как \<\hskwd{for}\>-нотация. Основное отличие от \<\hskwd{do}\>-нотации заключается в том, что она производит вызовы методов \<map\> и \<flatMap\> и потому ожидает чистое значение в качестве последнего выражения. Так, выражение вида

\begin{haskell}
\hskwd{for} \{\\
\quad\quad x \hsfrom List(1, 2, 3) \\
\quad\quad y \hsfrom List(4, 5, 6) \\
\} \hskwd{yield} x + y
\end{haskell}
\hspace{0cm}транслируется в
\begin{haskell}
List(1, 2, 3).flatMap(x \Rightarrow \\
\quad\quad List(4, 5, 6).map(y \Rightarrow \\
\quad\quad\quad x + y))
\end{haskell}

Также поддерживается фильтрация по условию, для чего генерируется вызов метода \<filter\>. 

\subsection{OCaml}
Для OCaml\cite{leroy2010objective} была разработана \<\hskwd{perfrom}\>-нотация\cite{carettesyntax}, близкая по синтаксису и реализации к рассмотренным нотациям в Haskell и Scala.

\begin{haskell}
\hskwd{perform} \\
\quad\quad x \longleftarrow [1; 2; 3]; \\
\quad\quad y \longleftarrow [4; 5; 6]; \\
\quad\quad return (x + y)
\end{haskell}
\hspace{0cm}раскрывается в
\begin{haskell}
bind [1; 2; 3] \\
\quad\quad\quad (\hskwd{fun} x \to bind [4; 5; 6] \\
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad (\hskwd{fun} y \to return (x + y)))
\end{haskell}

Стоит отметить, что, по аналогии с идиоматическими скобками, ни для \<\hskwd{do}\>, ни для \<\hskwd{for}\>, ни для \<\hskwd{perform}\> не нужна полноценная монада, достаточно полу-монады, вызов \<return\> или аналога нигде не генерируется.

\subsection{F$\sharp$}
F$\sharp$ предлагает более развитое синтаксическое средство для работы с монадами под названием \emph{вычислительные выражения}\cite{ComputationExpressions} (\eng{computation expressions}). Суть его заключается в переписывании выражения вида \<builderName \{ expression \}\>, где \<builderName\> соответствует имени построителя контекста (\eng{builder}), а \<expression\>~--- обыкновенный код на F$\sharp$, расширенный специальными синтаксическими конструкциями для связывания эффективных значений. Переписывание заключается в генерации вызовов методов построителя контекста.

Построитель контекста представляет собой объект, реализующий методы некоторого интерфейса. Обязательными методами являются \<Return\> и \<Bind\>, соответствующие монадической единице и монадического связыванию, а необязательными~--- ряд методов, соответствующих элементам языка, таким как циклы \<\hskwd{for}\> и \<\hskwd{while}\>, обработка исключений и конструкция \<\hskwd{if}\> без ветви \<\hskwd{else}\>.

Внутри переписываемого выражения различаются связывания чистых значений конструкциями \<\hskwd{let}\>, \<\hskwd{do}\>, \<\hskwd{yield}\> и \<\hskwd{use}\> и эффективных значений конструкциями \<\hskwd{let!}\>, \<\hskwd{do!}\>, \<\hskwd{yield!}\> и \<\hskwd{use!}\>.

В качестве примера рассмотрим работу с построителем контекста для типа \<'a option\>. Его интерфейс выглядит как

\begin{haskell}
\hskwd{type} OptionBuilder = \\
\quad\quad \hskwd{new}: unit \to OptionBuilder \\
\quad\quad \hskwd{member} Zero: unit \to 'a option \\
\quad\quad \hskwd{member} Bind: 'a option * ('a \to 'b option) \to 'b option \\
\quad\quad \hskwd{member} Return: 'a \to 'a option \\
\quad\quad \hskwd{member} ReturnFrom: 'a option \to 'a option
\end{haskell}

А реализация как

\begin{haskell}
\hskwd{type} OptionBuilder() = \\
\quad\quad \hskwd{member} b.Zero() = None \\
\quad\quad \hskwd{member} b.Bind(x, f) = \\
\quad\quad\quad\quad \hskwd{match} x \hskwd{with} \\
\quad\quad\quad\quad\quad\quad | Some x \to f x \\
\quad\quad\quad\quad\quad\quad | None \to None \\
\quad\quad \hskwd{member} b.Return x = Some x \\
\quad\quad \hskwd{member} b.ReturnFrom x = x : \_ option
\end{haskell}

Теперь объявив \<opt\> объектом построителя, можно пользоваться им как конструкцией языка.

\begin{haskell}
\hskwd{let} opt = OptionBuilder()
\end{haskell}

Будем рассматривать приложение, запрашивающее у пользователя простое число. В случае, если введённое число простое (что проверяется вхождением в заданный извне список \<primes\>), будет выведен его порядковый номер в списке, в противном случае будет выведено сообщение об ошибке.

Функция ввода простого числа.

\begin{haskell}
\hskwd{let} inputInt32() = opt \{ \\
\quad\quad \hskwd{let} str = Console.ReadLine() \\
\quad\quad \hskwd{let} success, value = Int32.TryParse str \\
\quad\quad \hskwd{if} success \hskwd{then} \hskwd{return} value \\
\} \\
\end{haskell}

Функция нахождения номера простого числа.

\begin{haskell}
\hskwd{let} tryInputPrime() = opt \{ \\
\quad\quad printfn \hsstr{Enter prime number:} \\
\quad\quad \hskwd{let!} prime = inputInt32() \\
\quad\quad \hskwd{let!} index = List.tryFindIndex ((=) prime) primes \\
\quad\quad \hskwd{return} prime, index + 1 \\
\} \\
\end{haskell}

Наконец, интерактивный диалог с пользователем.

\begin{haskell}
\hskwd{match} tryInputPrime() \hskwd{with} \\
\quad\quad | Some(prime, index) \to \\
\quad\quad\quad\quad printfn \hsstr{You did enter prime number \%d (№\%d)} prime index \\
\quad\quad | None \to \\
\quad\quad\quad\quad printfn \hsstr{The number you entered wasn't prime} \\
\end{haskell}

Также для вычислительных выражений добавляется расширение, названное \emph{джойнады}\cite{Petricek2011} (\eng{joinads}), вводящее конструкцию \<\hskwd{match!}\>, расширяющее нотацию сопоставления с образцом и используемое для параллельного и асинхронного программирования.

\section{Поддержка монад в \texttt{scala-workflow}}
Как было показано ранее, монады является частным случаем аппликативных функторов, добавляющими возможность специфицировать порядок вычислений с эффектами.

В качестве примера рассмотрим безопасную функцию деления вещественных чисел.

\begin{haskell}
\hskwd{def} divide(x:Double, y:Double) = \hskwd{if} (y == 0) None \hskwd{else} Some(x / y)
\end{haskell}

Выражение \<\$(divide(1, divide(2, 3)))\> нельзя раскрыть с помощью одних только идиом, поскольку для того, чтобы вычислить результат вызова внешнего \<divide\>, необходимо вычислить результат вызова вложенного \<divide\>. Для поддержки вложенных вычислений с эффектами необходимо расширить \texttt{scala-workflow} поддержкой монадических вычислений.

Эта поддержка монад сводится к добавлению новой операции для \<Workflow\>, расширению алгоритма раскрытия выражений и, как следствие, расширению поддерживаемого внутри $\$$ подмножества Scala.

\subsection{Расширенная иерархия вычислительных контекстов}
В иерархию вычислительных контекстов добавляется трейт \<Binding\>, содержащий метод \<bind\>, соответствующий монадическому связыванию.

\begin{haskell}
\hskwd{trait} Binding[F[\_]] \hskwd{extends} Workflow[F] \{ \\
\quad\quad \hskwd{def} bind[A, B](f:A \Rightarrow F[B]):F[A] \Rightarrow F[B] \\
\}
\end{haskell}

Также добавляются новые синонимы, соответствующие монаде и полумонаде. По аналогии с \<Idiom\>, для монады можно реализовать метод \<app\> с помощью \<point\> и \<bind\>.

\begin{haskell}
\hskwd{trait} SemiMonad[F[\_]] \hskwd{extends} SemiIdiom[F] \hskwd{with} Binding[F] \\
{}\\
\hskwd{trait} Monad[F[\_]] \hskwd{extends} Idiom[F] \hskwd{with} Binding[F] \{\\
\quad\quad \hskwd{def} app[A, B](f:F[A \Rightarrow B]) = \\
\quad\quad\quad bind(a \Rightarrow bind((g:A \Rightarrow B) \Rightarrow point(g(a)))(f))\\
\}
\end{haskell}

Поскольку монады не композируются, метода \<compose\>, как у прочих структур, у них нет. Возможность объявлять трансформеры монад и составлять композицию с их помощью, конечно, остаётся.

\subsection{Расширенный алгоритм раскрытия выражений}
Алгоритм раскрытия выражений остаётся, по существу, тем же, но добавляется специальный анализ зависимостей между эффективными значениями. В случае, когда одно подвыражение зависит от другого, будет сгенерирован вызов \<bind\>, а не \<app\>. В Таблице~\ref{table:monad-rewrite} показаны $\$$-выражения, производящие вызов \<bind\>.

Корректная обработка зависящих друг от друга эффективных вычислений позволяет добавить в поддерживаемое внутри идиоматических скобок подмножество Scala \<\hskwd{val}\>-объявления. Таблица~\ref{table:monad-val-rewrite} показывает, как будут переписаны некоторые из таких объявлений.


\begin{table}\small
\begin{tabularx}{\textwidth}{|X|X|}

\hline

\textbf{\$-выражение} & \textbf{Раскрытое выражение} \tabularnewline

\hline

{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
\$ ~\{ \\
\quad \hskwd{val} ~x = Some(10) \\
\quad x + 2 \\
\}
\end{haskell}\vspace*{-22pt}\end{minipage}}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.map( \\
\quad (x:Int) \Rightarrow \\
\quad\quad x + 2 \\
)(Some(10))
\end{haskell}\vspace*{-22pt}\end{minipage}}
\tabularnewline

\hline

{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
\$ ~\{ \\
\quad \hskwd{val} ~x = Some(10) \\
\quad \hskwd{val} ~y = Some(5) \\
\quad x + y \\
\}
\end{haskell}\vspace*{-22pt}\end{minipage}}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.bind( \\
\quad (x:Int) \Rightarrow \\
\quad\quad option.map( \\
\quad\quad\quad (y:Int) \Rightarrow \\
\quad\quad\quad\quad x + y \\
\quad\quad )(Some(5)) \\
)(Some(10))
\end{haskell}\vspace*{-22pt}\end{minipage}}
\tabularnewline

\hline

{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
\$ ~\{ \\
\quad \hskwd{val} ~x = Some(10) \\
\quad \hskwd{val} ~y = x - 3 \\
\quad x \times y \\
\}
\end{haskell}\vspace*{-22pt}\end{minipage}}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.map( \\
\quad (x:Int) \Rightarrow \\
\quad\quad ~\hskwd{val} ~y = x - 3 \\\
\quad\quad x \times y \\
)(Some(10))
\end{haskell}\vspace*{-22pt}\end{minipage}}
\tabularnewline

\hline

{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
\$ ~\{ \\
\quad \hskwd{val} ~x = Some(10) \\
\quad divide(x, 2) \\
\}
\end{haskell}\vspace*{-22pt}\end{minipage}}
&
{\onehalfspacing\hspace*{-28pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.bind( \\
\quad (x:Int) \Rightarrow \\
\quad\quad divide(x, 2) \\
)(Some(10))
\end{haskell}\vspace*{-22pt}\end{minipage}}
\tabularnewline

\hline

{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
\$ ~\{ \\
\quad \hskwd{val} ~x = Some(10) \\
\quad x \times Some(2) + Some(5) \\
\}
\end{haskell}\vspace*{-22pt}\end{minipage}}
&
{\onehalfspacing\hspace*{-28pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.bind( \\
\quad (x:Int) \Rightarrow \\
\quad\quad option.app( \\
\quad\quad\quad option.map( \\
\quad\quad\quad\quad (x_1:Int) \Rightarrow (x_2:Int) \Rightarrow \\
\quad\quad\quad\quad\quad x \times x_1 + x_2 \\
\quad\quad\quad )(Some(2)) \\
\quad\quad )(Some(5)) \\
)(Some(10))
\end{haskell}\vspace*{-22pt}\end{minipage}}
\tabularnewline

\hline

{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
\$(2 + ~\{ \\
\quad \hskwd{val} ~x = Some(10) \\
\quad x \times 2 \\
\})
\end{haskell}\vspace*{-22pt}\end{minipage}}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.map( \\
\quad (x_1:Int) \Rightarrow \\
\quad\quad 2 + x_1 \\
)(option.map( \\
\quad (x_2:Int) \Rightarrow \\
\quad\quad x_2 \times 2 \\
)(Some(10)))
\end{haskell}\vspace*{-22pt}\end{minipage}}
\tabularnewline

\hline

\end{tabularx}
\label{table:monad-val-rewrite}
\caption{Раскрытие $\$$-выражений, содержащих $\mathtt{val}$-объявления.}
\end{table}


\begin{table}[h]\small
\begin{tabularx}{\textwidth}{|X|X|}

\hline

\textbf{\$-выражение} & \textbf{Раскрытое выражение} \tabularnewline

\hline

\<\$(divide(1, 2))\> & \<divide(1, 2)\> \tabularnewline

\hline

{\vspace{-16pt}\<\$(divide(Some(1.5), 2))\>}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.bind( \\
\quad (x_1:Double) \Rightarrow \\
\quad\quad divide(x_1, 2) \\
)(Some(1.5))
\end{haskell}\vspace*{-22pt}\end{minipage}} \tabularnewline

\hline

{\vspace{-15pt}\<\$(divide(Some(1.5), Some(2)))\>}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.bind( \\
\quad (x_1:Double) \Rightarrow \\
\quad\quad option.bind( \\
\quad\quad\quad (x_2:Int) \Rightarrow \\
\quad\quad\quad\quad divide(x_1, x_2) \\
\quad\quad )(Some(2)) \\
)(Some(1.5))
\end{haskell}\vspace*{-22pt}\end{minipage}} \tabularnewline

\hline

{\vspace{-15pt}\<\$(divide(Some(1.5), 2) + 1)\>}
&
{\onehalfspacing\hspace*{-34pt}\begin{minipage}{\textwidth}\vspace*{-7pt}\begin{haskell}
option.bind( \\
\quad (x_1:Double) \Rightarrow \\
\quad\quad option.map( \\
\quad\quad\quad (x_2:Double) \Rightarrow \\
\quad\quad\quad\quad x_2 + 1 \\
\quad\quad )(divide(x_1, 2)) \\
)(Some(1.5))
\end{haskell}\vspace*{-22pt}\end{minipage}} \tabularnewline

\hline

\end{tabularx}
\label{table:monad-rewrite}
\caption{Раскрытие $\$$-выражений, производящие вызов \emph{bind}.}
\end{table}

\section{Приложения}
\subsection{Вычисления с ошибками}
Scala не поддерживает проверяемые исключения, т.е. в сигнатуре функции нельзя указать выбрасываемые ей исключения. Фактически, информация о вычислительном эффекте игнорируется компилятором и доступна только во время выполнения. Начиная с версии 2.10 в Scala доступна специальная монада \texttt{scala.util.Try}, которая позволяет обернуть чистое значение в аннотацию возможно выброшенного в процессе работы исключения. Конструктор \<Try\> позволяет превратить вычисление в эффективное значение.

При этом переход от стиля программирования с исключениями на стиль программирования с \<Try\> сопровождается серьёзными изменениями в синтаксисе, избежать которых помогает \texttt{scala-workflow}.

Для примера рассмотрим просто код, получающий XML-документ по сети. Его прямая реализация с использованием исключений выглядит следующим образом.

\begin{haskell}
\hskwd{def} fetchXml(address:String):Elem = \{ \\
\quad\quad \hskwd{val} url = \hskwd{new} URL(address) \\
\quad\quad \hskwd{val} source = io.Source.fromURL(url) \\
\quad\quad \hskwd{val} contents = source mkString \hsstr{} \\
\quad\quad XML.fromString(contents) \\
\}
\end{haskell}

Система исключений инкапсулирует по-крайней мере три ошибочных ситуации в этом коде. Во-первых, \<address\> может оказаться невалидным URL, во-вторых попытка сделать запрос по сети может закончиться неудачей, в-третьих строка \<contents\> может оказаться некорректным XML-документом. При этом в тип функции никак не сообщается, что она на этапе выполнения она может произвести исключение.

Закодировав результат функции в типе \<Try[Elem]\> можно воспользоваться \<\hskwd{for}\>-синтаксисом, чтобы переписать реализацию функции.

\begin{haskell}
\hskwd{def} fetchXml(address:String):Try[Elem] = \hskwd{for} \{ \\
\quad\quad url \hsfrom Try(\hskwd{new} URL(address)) \\
\quad\quad source \hsfrom Try(io.Source.fromURL(url)) \\
\quad\quad contents = source mkString \hsstr{} \\
\quad\quad xml \hsfrom Try(XML.fromString(contents)) \\
\} \hskwd{yield} xml
\end{haskell}

Помимо оборачивания вычислений, выбрасывающих исключения, в конструктор \<Try\>, пришлось изменить структуру самой функции. Благодаря \texttt{scala-worflow}, этот же код можно записать как

\begin{haskell}
\hskwd{def} fetchXml(address:String):Try[Elem] = workflow[Try] \{ \\
\quad\quad \hskwd{val} url = Try(\hskwd{new} URL(address)) \\
\quad\quad \hskwd{val} source = Try(io.Source.fromURL(url)) \\
\quad\quad \hskwd{val} contents = source mkString \hsstr{} \\
\quad\quad Try(XML.fromString(contents)) \\
\}
\end{haskell}

Отличие от кода, не кодирующего эффекты в типе минимально~--- добавилась лишь аннотация вычислительного контекста.

\subsection{Вычисления с накапливаемым выводом}
Рассмотрим реализацию монады \<Writer\>, используемой для вычислений с накапливаемым побочным эффектом. Результатом таких вычислений становится пара из вычисленного значения и накопленного эффекта. Формализуем его в виде класса \<Writer\>.

\begin{haskell}
\hskwd{case} \hskwd{class} Writer[R, O](result:R, output:O)
\end{haskell}

Накапливаемый результат должен реализовывать интерфейс моноида. Нейтральный элемент моноида соответствует отсутствующему эффекту вычисления, а ассоциативная операция позволяет слить два эффекта в один. Следующее определение формализует моноид в Scala.

\begin{haskell}
\hskwd{trait} Monoid[A] \{ \\
\quad\hskwd{def} empty:A \\
\quad\hskwd{def} append:(A, A) \Rightarrow A \\
\}
\end{haskell}

Теперь можно объявить реализацию монады \<Writer\>.

\begin{haskell}
\hskwd{implicit} \hskwd{def} writer[O:Monoid] = \hskwd{new} Monad[Writer[_, O]] \{ \\
\quad\hskwd{private} \hskwd{val} monoid = implicitly[Monoid[O]] \\
\quad\hskwd{def} point[A](a:A) = Writer(a, monoid.empty) \\
\quad\hskwd{def} bind[A, B](f:A \Rightarrow Writer[B, O]) = \{ \\
\quad\quad\hskwd{case} Writer(a, o) \Rightarrow \\
\quad\quad\quad\hskwd{val} Writer(b, o2) = f(a) \\
\quad\quad\quad\hsnothing{Writer(b, monoid.append(o, o2))}\\
\quad\}\\
\}
\end{haskell}

В качестве накапливаемого вывода рассмотрим тривиальный пример лог-файла, состоящего из списка строк, представляющих записи в логе.

\begin{haskell}
\hskwd{case} \hskwd{class} Log(entries:List[String])
\end{haskell}

Реализация моноида для лога, фактически, опирается на реализацию моноида для списка.

\begin{haskell}
\hskwd{implicit} \hskwd{val} logMonoid = \hskwd{new} Monoid[Log] \{ \\
\quad\hskwd{def} empty = \hskwd{new} Log(Nil) \\
\quad\hskwd{def} append = \{ \\
\quad\quad\hskwd{case} (Log(oldentries), Log(newentries)) \Rightarrow \\
\quad\quad\quad\hsnothing{Log(oldentries \hsapp newentries)} \\
\quad\} \\
\}
\end{haskell}

В качестве эффективной функции объявим \<log\>, возвращающую экземпляр \<Writer\> с отсутствующим значением и логом, состоящим из одной записи.

\begin{haskell}
\hskwd{def} log(message:String) = \\
\quad{Writer[Unit, Log](\{\}, \hskwd{new} Log(List(message)))}
\end{haskell}

Теперь можно строить вычисления внутри контекста \<Writer[\_, Log]\>, реализация монады разделит чистое значение и эффект.

\begin{haskell}
\hskwd{val} Writer(result, log) = workflow(writer[Log]) \{ \\
\quad\quad log(\hsstr{Calculating the sum...}) \\
\quad\quad \hskwd{val} sum = 2 + 2 \\
{}\\
\quad\quad \hskwd{val} product = 2 \times 2 \\
{}\\
\quad\quad log(\hsstr{Calculating the subtraction...}) \\
\quad\quad \hskwd{val} subtraction = 10 - 7 \\
{}\\
\quad\quad log(\hsstr{Calculating the division...}) \\
\quad\quad 30 \div 5 \\
\}
\end{haskell}

Полученный код представляет собой чисто функциональную версию записи в лог файл. В его традиционном императивном аналоге, функция \<log\> производила бы неконтролируемый системой типов побочный эффект. В этой же реализации результат вычисления доступен в переменной \<result\> и равен $6$, а накопленный лог-файл оказывается в переменной \<log\>. При этом \texttt{scala-workflow} позволило не менять реализацию при переходе от императивной версии к чисто функциональной.

\subsection{Асинхронное программирование}
В параграфе \ref{subsec:idioms-async} было упомянуто, что класс \<Future\> реализует монадический интерфейс. Рассмотрим отличия асинхронного программирования в монадическом контексте от аппликативного.

Перепишем функцию \<slowly\> так, чтобы она сразу возвращала \<Future\>.

\begin{haskell}
\hskwd{def} slowly[A](proc: \Rightarrow A) = Future \{ \\
\quad{Thread.sleep(1000)}\\
\quad{proc}\\
\}
\end{haskell}

Рассмотрим выражение \<\$(slowly(slowly(2) \times 2))\>, допустимое в монадическом, но не аппликативном контексте. Ранее было отмечено, что одно из отличий между ними заключается в том, что монады поддерживают нотацию зависимости между результатами промежуточных вычислений. Так и в этом случае, внешний вызов \<slowly\> сможет начать вычислений только когда будет известен результат вызова внутреннего, а значит и вычисление всего выражение займёт две секунды.

Перепишем код из параграфа \ref{subsec:idioms-async} в монадическом контексте.

\begin{haskell}
workflow[Future] \{ \\
\quad\hskwd{val} x = slowly(2 \times 3) \\
\quad\hskwd{val} y = slowly(4 - 1) \\
\quad{x \times y} \\
\}
\end{haskell}

Запустив код, можно убедиться, что и его выполнение теперь занимает не одну секунду, а две, фактически, каждое выражение стало блокирующим! Это связано с тем, что блоки с \<\hskwd{val}\> всегда раскрываются в вызовы методов \<\hskwd{bind}\>, даже в случае, когда зависимостей между связываниями эффективных значений нет.

\subsection{Монадические EDSL}
По аналогии с EDSL, построенными на основе аппликативных функторов, для формализации вычислений можно использовать и монады. Упомянутая ранее возможность монад производить вычисления, зависящие от результата друг друга позволяет описывать произвольный поток управления для встраиваемого языка, что значительно повышает их выразительную силу. 

Рассмотрим пример встраиваемого в Scala стекового языка программирования. Его реализация основана на вычислении в монаде \<State\>, причём поток выполнения зависит от состояния стека и вычисление может завершиться досрочно в случае возникновения ошибки обращения к стеку. \texttt{scala-workflow} позволяет построить конкатенативный синтаксис, близкий к синтаксису аналогичных языков (таких как Forth\cite{brodie2004thinking} и Joy\cite{von2001joy}), чего было бы невозможно добиться с использованием одних только \<\hskwd{for}\>-выражений.

Будем представлять стек в виде обыкновенного неизменяемого списка, а результат выполнения программы как либо модифицированное состояние стека, либо сообщение об ошибке (такое как <<stack underflow>>).

\begin{haskell}
\hskwd{type} Stack = List[Int] \\
\hskwd{type} Result = Either[String, Stack]
\end{haskell}

Интерпретация программы задействует монаду \<state\>, которая игнорирует результат выполнения каждой отдельной команды, но сохраняет состояние стека.

\begin{haskell}
\hskwd{val} stackLang = state[Result] \\ 
\hskwd{def} execute(program: State[Unit, Result]) = program.state(Right(Nil))
\end{haskell}

Операции над стеком являются функциями типа \<Stack \Rightarrow Result\>. Чтобы иметь возможность пользоваться ими внутри какого-нибудь вычислительного контекста, необходимо поднять их в монаду.

\begin{haskell}
\hskwd{def} command(f: Stack \Rightarrow Result) = \\
\quad\quad State[Unit, Result](st \Rightarrow (\{\}, right[String].bind(f)(st)))
\end{haskell}

Теперь, пользуясь функцией \<command\>, можно объявить несколько команд, работающих со стеком.

\begin{haskell}
\hskwd{def} put(value: Int) = command \{ \\
\quad\quad \hskwd{case} stack \Rightarrow Right(value :: stack) \\
\} \\
{} \\
\hskwd{def} dup = command \{ \\
\quad\quad \hskwd{case} head :: tail \Rightarrow Right(head :: head :: tail) \\
\quad\quad \hskwd{case} \_ \Rightarrow Left(\hsstr{Stack underflow while executing `dup`}) \\
\} \\
{} \\
\hskwd{def} rot = command \{ \\
\quad\quad \hskwd{case} a :: b :: stack \Rightarrow Right(b :: a :: stack) \\
\quad\quad \hskwd{case} \_ \Rightarrow Left(\hsstr{Stack underflow while executing `rot`}) \\
\} \\
{} \\
\hskwd{def} sub = command \{ \\
\quad\quad \hskwd{case} a :: b :: stack \Rightarrow Right((b - a) :: stack) \\
\quad\quad \hskwd{case} \_ \Rightarrow Left(\hsstr{Stack underflow while executing `sub`}) \\
\}
\end{haskell}

Программой, написанной в конкатенативном стиле является последовательность вызовов операций над стеком внутри идиоматических скобок  контекста \<stackLang\>. 

\begin{haskell}
context(stackLang) \{ \\
\quad\quad \hskwd{val} programA = \$ \{ put(5); dup; put(7); rot; sub \} \\
\quad\quad execute(programA) == Right(List(2, 5)) \\
{} \\
\quad\quad \hskwd{val} programB = \$ \{ put(5); dup; sub; rot; dup \} \\
\quad\quad execute(programB) == Left(\hsstr{Stack underflow while executing `rot`}) \\
\}
\end{haskell}

\likechapter{Заключение}
Результатом данной работы является расширение языка Scala под названием \texttt{scala-workflow}, реализованное с помощью средств метапрограммирования и предназначенное для упрощения синтаксиса вычислений с эффектами, формализованными функторами, аппликативными функторами и монадами. Реализация построена на основе нетипизированных макросов, на момент написания работы доступных в экспериментальной ветке компилятора Scala.

Отметим особенности, отличающие \texttt{scala-workflow} от аналогов и составляющих новизну работы:
\begin{enumerate}
  \item Вычисления с эффектами представляют собой обыкновенный код на Scala, обёрнутый в аннотацию контекста, т.е. максимально приближенный к синтаксису чистых вычислений, в отличии от похожих расширений, вводящих для этой цели специальные синтаксические конструкции.
  \item Описывается единообразный синтаксис для вычислений со всеми образующими иерархию формализациями эффектов, чего ранее не было представлено. Идиоматические скобки и \<\hskwd{do}\>/\<\hskwd{for}\>-нотация рассчитаны на работу только с аппликативными функторами и монадами соответственно.
  \item Большая модульность. Не ожидается, что инстанс \<Workflow\> должен реализовывать интерфейс какой-то конкретной структуры, раскрытие выражение всегда происходит в вызовы наиболее слабого необходимого интерфейса, от реализации требуются только те методы, которые нужны в конкретном случае (в отличии, к примеру, от \<\hskwd{do}\>-нотации, которая всегда подразумевает монаду, даже в случаях, когда описываемое ей вычисление может быть выражено и более слабой структурой). До некоторой степени это похоже на вычислительные выражения в F$\sharp$, с поправкой на то, что вычислительные выражения всё же ожидают интерфейс монады, расширенный некоторыми дополнительными методами, в то время как контекст \texttt{scala-workflow} может реализовывать и всего один самый базовый метод функтора.
\end{enumerate}

Помимо упрощения вычислений с эффектами \texttt{scala-workflow} может использоваться и в качестве синтаксического фреймворка для построения аппликативных и монадических EDSL, что следует из двойственной природы рассматриваемых в работе формализаций эффектов.

Необходимо отметить недостатки разработанного решения:
\begin{enumerate}
  \item Не всегда очевидно, какой код будет в итоге сгенерирован. В отличие от рассмотренных синтаксических расширений, \texttt{scala-workflow} не просто применяет правила синтаксического преобразования к выражениям, но рассматривает типы подвыражений, что затрудняет анализ.
  \item В частности, не всегда очевидно, какой набор методов контекста необходим для раскрытия заданного участка кода. Это вполне очевидно для простых выражений, но не всегда для сложных.
  \item Поскольку макросы, переписывающие выражение, принимают в общем случае некорректное с точки зрения системы типов Scala выражение, становится трудно корректно сообщить об ошибке типов, произошедшей во время раскрытия в случае, если исходное выражение было ошибочно составлено так, что не проходит проверку типов, будучи раскрытым. Текущая реализация не поддерживает полноценной обработки ошибок и этот вопрос, предполагается, будет решён в будущем.
  \item Добавление нового нетривиального этапа увеличивает время компиляции (впрочем, ненамного).
  \item Implicit-преобразования могут вмешиваться в работу раскрытия выражений, из-за чего подвыражения могут случайно проходить проверку типов. На текущий момент способов решения этой проблемы не найдено.
\end{enumerate}

\likechapter{Дальнейшая работа}
\texttt{scala-workflow} уже сейчас пригодно для использования и разработка будет продолжена как в теоретическом, так и в прикладном аспектах.

\textbf{Расширение поддерживаемого множества языка.} Scala~--- сложный язык с очень развитой семантикой. Помимо элементов чисто функциональных языков программирования, здесь присутствует изменяемое состояние, исключения и implicit-преобразования, вычисления с которыми могут потребовать добавления новых методов к \<Workflow\>. Такой подход очень близок к текущей реализации вычислительных выражений в F$\sharp$, где большая часть методов представляет собой поддержку особенностей языка.

\textbf{Вывод контекста из типа.} \texttt{scala-worflow} позволяет в большинстве случаев уменьшить количество boilerplate-кода. Уменьшить его ещё больше можно было бы, выводя контекст из типов подвыражений аргумента в простых случаях. Например, считать выражение \<List(1, 2, 3) \times 2\> помещённым по умолчанию в контекст \<Workflow[List]\> и иметь возможность писать \<\$(List(1, 2, 3) \times 2)\> без указания контекста где-либо. Построение алгоритма вывода контекста связано с рядом проблем:
\begin{enumerate}
  \item Неясно, как выбрать, по какому типовому аргументу абстрагировать контекст, если используется типовый конструктор от нескольких аргументов. Например, встретив выражение типа \<Either[A, B]\> неясно, следует ли вывести контекст для \<Either[A, \_]\> или для \<Either[\_, B]\>.
  \item Неясно, какой выбрать подтип, если встреченный в выражении тип участвует в иерархии наследования. Например, сейчас выражение \<Some(42)\> имеет тип \<Some[Int]\>, являющийся подтипом \<Option[A]\>. Не\-обходимо построить алгоритм, способный вывести в таком случае контекст для \<Option\>, а не для \<Some\>.
\end{enumerate}

\textbf{Вывод контекста из интерфейса.} Как упоминалось ранее, Scala не выделяет монаду в отдельный интерфейс, раскрытие \<\hskwd{for}\>-выражения просто ожидает наличие методов \<map\>, \<flatMap\> и \<filter\> у объекта. Сейчас это приводит к тому, что для каждого типа, неявно поддерживающего монадический интерфейс, приходится писать тривиальную реализацию \<Workflow\>. Хорошей альтернативой стала бы возможность выводить контекст полумонады из наличия методов \<map\> и \<flatMap\> в интерфейсе некоторой структуры.

\textbf{Расширения системы типов.} Алгоритм с переписыванием выражений до прохождения проверки типов весьма хрупок и ненадёжен. Хорошей альтернативой стала бы система типов, в которой правило применения типа расширено на случай применения к эффективному аргументу. Исследование подобной системы типов предполагает решение задач проверки типа (\eng{type checking problem}), синтеза типов (\eng{type synthesis problem}) и населённости типа (\eng{type inhabitance problem}), а также вопроса устойчивости (\eng{type soundness}) такой системы типов.

\textbf{Прочие формализации эффектов.} Большой интерес представляют альтернативные способы описания эффектов, рассмотренные в первой части работы. Необходимо понять, существует ли более естественный способ отображения элементов языка в композицию операций над какой-либо алгебраической структурой, формализующей эффективное значение. Это могло бы позволить точнее гранулировать мощь вычислительного контекста и дать возможность для некоторых контейнеров использовать синтаксис, невозможный при текущих правилах отображения.

\input{bibliography}
\end{document}